---
title: Mapping US Census data
author: Jerid Francom
date: '2016-02-06'
slug: mapping-us-census-data
summary: 'In this exploRation I will provide a tutorial on 1) how to acquire the US census data and other demographic data through American Fact Finder, 2) how to visualize the data in regional choropleths, 3) how to overlay geo-tagged tweets, and finally 4) how to display the map as an interactive plot.' 
categories:
  - R
tags:
  - census
  - plot
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library(EBImage)
```

I'm currently working on a project involving Twitter posts and demographics. One of the best resources for demographic information in the US is the census. Having not worked with US census data in a very long time, I was excited to see that there is an R package available to make the process easier. 

In this exploRation I will provide a tutorial on 1) how to acquire the US census data and other demographic data through American Fact Finder, 2) how to visualize the data in regional choropleths, 3) how to overlay geo-tagged tweets, and finally 4) how to display the map as an interactive plot.

In this post I'll tackle the first two points and leave Twitter data and interactive plots for a follow up post.

A handy package for working with US Census data in R is the `UScensus2010` package. It is available on [CRAN](https://cran.r-project.org/web/packages/UScensus2010/index.html) and can be installed in the normal way.

```{r, eval=FALSE}
install.packages("UScensus2010")
```

It is a helper package to interface the spatial and demographic data that is available in a series of other packages dedicated to varying political and statistical regions: namely `UScensus2010tract`, `UScensus2010cdp`, `UScensus2010county`, `UScensus2010blkgrp`, and `UScensus2010blk`.
 
In this tutorial I'll be working with the "tract" level [[US Census Tract description](http://tigerweb.geo.census.gov/tigerwebmain/TIGERweb2010_geography_details.html#TRACT)]. A tract is a small subdivision of a county. In this particular case I want to explore the Tucson, Arizona metropolitain area. County would be too wide, and city boundaries too narrow. 

`UScensus2010` provides an installer fuction `install.tract()` which should install the tract data on your machine. I found problems, however, with the installer, and had to do some poking around on the web. Luckily, I found a repository where the data can be manually downloaded and installed.

```{r get-tract-data, eval=FALSE}
url <- "http://lakshmi.calit2.uci.edu/census2000/R/src/contrib/UScensus2010tract_1.00.tar.gz"
install.packages(url, repos = NULL)
```

With the tract data downloaded and installed, it can be loaded using the `city()` or `county()` function. Again, I want county-level information here. Tucson belongs to "Pima" county. ^[I've specified `level = "tract"` to get access to the tract data that we installed, but if you have downloaded other UScensus package data you can specify which you want to pull.]

```{r get-pima, warning=FALSE, message=FALSE, error=FALSE}
library(UScensus2010)
pima.tract <- UScensus2010::county(name = "pima", state = "arizona", level = "tract")
```

The resulting data in `pima.tract` is a SpatialPolygonsDataFrame grouping demographic data and polygon coordinates by tract id.

A map can be generated in various ways. First, base R's `plot()` function will produce a quick and dirty view of the tracts for Pima county.

```{r plot-pima}
plot(pima.tract)
```

`UScensus2010` also provides various plotting functions. Of these the `choropleth.ssplot()` function is an easy way to generate a choropleth. Using the defaults, the "Total population" (P0010001) variable is used to fill the tracts. [For more information on demographic variables](http://www.socialexplorer.com/data/C2010/metadata/?ds=SF1)

```{r choropleth-ssplot}
choropleth.spplot(pima.tract)
```

If you are like me, I am more comfortable working with `ggplot2`. To work with this data, however, it needs to be converted to a data.frame using the ~~`fortify()`~~UPDATED: 2016-03-08 `tidy()` function from the `broom` package. Below is a function that carries out the conversion from `sp` object to `data.frame` object.

*Thanks to [Andy Bush](http://www.urbanchildinstitute.org/about-us/contributors#Andy-Bush) for the heads up on switching to `tidy()` before `fortify()` depreciates.*

```{r sp2df}
sp2df <- function(data) {
  data@data$id <- rownames(data@data)
  data.points = broom::tidy(data, region = "id")
  data.df = plyr::join(data.points, data@data, by = "id")
  return(data.df)
}
```

Then we create the data.frame version of the data.

```{r}
pima.tract.df <- sp2df(pima.tract)
```

Let's produce a simple choropleth with `P0010001` ("Total population") as the fill aesthetic as a above.

```{r pima-ggplot}
library(ggplot2)
p <- ggplot(pima.tract.df, aes(x = long, y = lat, group = group)) + 
  geom_polygon(aes(fill = P0010001), colour = alpha("white", 1/2), size = 0.5) +
  theme(legend.position = "bottom") +
  labs(fill = "Total population")
p
```

The county plot is extremely dense around the area of interest --the Tucson metropolitain area. With `ggplot2` we can subset this plot with `coord_map()`. But to use this we are going to need the coordinates for the bounding box. I found [a great site](http://boundingbox.klokantech.com) which provides a easy-peasy interface for doing just such a thing. 

```{r bbox-img, echo=FALSE}
img <- readImage(files = "images/bbox.png")
display(img)
```

```{r tucson-ggplot}
p + coord_map(xlim=-c(111.2, 110.7), ylim=c(32.1, 32.5))
```

There is an extensive amount of demographic information that is available in the `sp` object that `county()` creates. But there is much more information available on the [American FactFinder](http://factfinder.census.gov/faces/nav/jsf/pages/download_center.xhtml) site. I am working with a project which aims to look at language use information so I selected the tract information for Pima county on from the American Community Survey (ACS) program's 2014 5-year estimates and downloaded the "AGE BY LANGUAGE SPOKEN AT HOME FOR THE POPULATION 5 YEARS AND OVER" (B16007) data.

The second row of the csv file contains helpful descriptions of the variables, but I dropped it before loading it into my R session.

```{r pima-aff, message=FALSE}
library(readr)
pima.lang.df <- read_csv("data/ACS_14_5YR_B16007.csv", 
                col_names = TRUE)
```

Now what I want to do is join the `pima.tract.df` and the new `pima.lang.df` datasets. The common key between both sets is the `$fips` (Federal Information Processing Standard) codes. Yet in the `pima.lang.df` data this is listed as `$GEO.id2`. Furthermore, in the `pima.tract.df` the `$fips` variable is of type character, and needs to be numeric for direct merging. 

```{r join-data, message=FALSE, warning=FALSE}
pima.lang.df <- plyr::rename(pima.lang.df, c("GEO.id2"="fips"))
pima.tract.df$fips <- as.numeric(pima.tract.df$fips)

pima.data <- plyr::join(pima.tract.df, pima.lang.df)

# remove tracts with incomplete data
pima.data <- na.omit(pima.data) 
```

To look at the Spanish-speaking population, I pull the estimates for Spanish-speaking 5 to 17, 18 to 64, and 65 plus and add them together and then divide this vector by the total estimate of speakers in the tract.

```{r spanish-variables}
estimate.span.5.17 <- pima.data$HD01_VD04 # 5 to 17
estimate.span.18.64 <- pima.data$HD01_VD10 # 18 to 64
estimate.span.65.plus <- pima.data$HD01_VD16 # 65 plus

span.total <- estimate.span.5.17 + estimate.span.18.64 + estimate.span.65.plus
speakers.total <- pima.data$HD01_VD01
```

We can use this information to fill the choropleth and convert the vector scores into percentages per tract.

```{r spanish-choro}
p <- ggplot(pima.data, 
            aes(long, lat, group = group)) +
  geom_polygon(aes(fill = (span.total/speakers.total)*100), 
               colour = alpha("white", 1/2), size = 0.2) + 
  scale_fill_gradient(name="% Spanish speaking") +
  coord_map(xlim=-c(111.2, 110.7), 
            ylim=c(32.1, 32.5)) + 
  theme(legend.position = "bottom")
p
```

Getting a bit more fancy we can overlay this plot on a roadmap generated by Google.

```{r spanish-choro-google, warning=FALSE, message=FALSE}
library(ggmap)
pima <- get_map(location = geocode(location = "tucson"), 
                source = "google", 
                zoom = 10, 
                maptype = "roadmap", 
                color = "bw")

p.roadmap <- ggmap(pima) + 
  geom_polygon(data = pima.data, 
               aes(long, lat, group = group, 
                   fill = (span.total/speakers.total)*100, 
                   alpha = (span.total/speakers.total)*100), size = .25) + 
  coord_map(xlim=-c(111.2, 110.7), 
            ylim=c(32.1, 32.5)) + 
  theme(legend.position = "none")
p.roadmap
```

In the next post I will incorporate data from Twitter and step up the plots using `plotly`.
