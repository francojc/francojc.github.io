---
title: Mapping US Census data and adding Twitter posts
author: Jerid Francom
date: '2016-03-08'
slug: mapping-us-census-data-and-adding-twitter-posts
summary: 'In this post I will step through how to integrate geo-tagged tweets into the choropleth plots I created in the previous post, "Mapping US Census data". I will also show how you can use the `plotly` package to make the plot interactive and enable a hover-over effect to display the tweet content.'
categories:
  - R
tags:
  - census
  - plot
  - plot.ly
  - mapping
---

```{r data, echo=FALSE, message=FALSE, warning=FALSE}
load("data/tweets.RData")
load("data/census-I-data-output.RData")
library(tidyverse)
```

Not all tweets have geolocation information available. Accessing the Twitter API via the `streamR` package particular parameters can be set to only include those tweets with geolocation enabled. You can also specify a bounding box to further filter the geographic area from which you would like to draw your sample tweets. Now, the bounding box is going to be just that, a box. And we are dealing with polygons. To isolate tweets from a specific geo-political region, such as a census tract, you can use the `sp` package. For the details on how to both get geo-tagged tweets in R and how to clip the tweets to fit a specific spatial object polygon, refer to my previous post [Access Twitter posts by country](http://francojc.github.io/access-twitter-posts-by-country/).

```{r clip-and-merge, echo=FALSE, warning=FALSE, message=FALSE}
library(data.table) # tweets are stored in data.table format
library(sp) # spatial data library
library(plyr) # data manipulation
# Subset tweet lon/ lat for Pima coordinates
coords <- data[, .(lon, lat)]
coordinates(coords) <- c("lon", "lat")
proj4string(coords) <- proj4string(pima.tract)
pima.coords <- coords[pima.tract, ]
pima.coords <- as.data.table(pima.coords@coords)

# Join tweet data with coordinates inside Pima county
setkey(pima.coords, lon, lat)
setkey(data, lon, lat)
pima.tweets <- join(pima.coords, data)

# Remove unnecessary variables
rm(coords, pima.coords, pima.tract, data)
```

**Picking up from last time**

Our starting point, therefore, looks like this:

```{r variables}
ls()
```

`p` and `p.roadmap` are the plots and `span.total` and `speakers.total` are the variables I created in the [last post](https://francojc.github.io/2016/02/06/mapping-us-census-data/) based on the American Fact Finder data to visualize the level of Spanish speakers by census tract.

```{r p-base, warning=FALSE, error=FALSE, echo=FALSE}
p
p.roadmap
```

Here I will be working with a small set of tweets collected from Twitter and clipped to only include posts that emanated from within Pima county, Arizona --the county in which Tucson resides. So here's a quick look at the variables in the data:

```{r tweet-data, comment=""}
pima.tweets %>% names
```

There is plenty of interesting information you can play around with --but note, fields with user input often contain unreliable information. In this post I'll only need a few key features (`lon`, `lat`, and `text`) and include one other (`lang`) which facilitates my aim to explore the relationship between language choice on Twitter and US Census demographic information. 

```{r pima-tweet-sub}
pima.tweets <- subset(pima.tweets, 
                      select = c("lon", "lat", "text", "lang"))
```

<!-- Plot tweets on `p` standard plot -->
To include points on our map corresponding to Twitter posts we use the `geom_point` function including specifying the `pima.tweets` dataset.

```{r p-tweets-standard, warning=FALSE}
p + geom_point(data = pima.tweets,
               aes(x = lon, y = lat, group = 1))
```

There are various aesthetics that `ggplot2` makes available that we can use to visualize language (`lang`). In this case I don't want to see languages other than English and Spanish so I will subset the data using `en` and `es` and map it to the `color` aesthetic. Note that I'm naively trusting the language detection algorithm that Twitter uses.


```{r p-road-tweets-aes, warning=FALSE}
pima.tweets <- subset(pima.tweets, lang == 'en' | lang == 'es')

p + geom_point(data = pima.tweets,
                       aes(x = lon, y = lat, group = 1, 
                           color = lang)) +
  scale_color_manual(values = c("yellow","red"), name = "Language")
```

If you're me, you're thinking it would be cool to see what the content of these tweets are. The `plotly` package can be hooked up with `ggplot2` and you can get a really cool effect in which the text appears on hovering over a point on the map.

Just load the `plotly` library, create your standard plot, and then apply the `ggplotly()` function.

<!-- Introduce `plotly`, create interactive plots -->
```{r p-road-tweets-aes-plotly, warning=FALSE, message=FALSE}
library(plotly)
pp <- p + geom_point(data = pima.tweets,
                       aes(x = lon, y = lat, group = 1, 
                           color = lang, text = text)) +
  scale_color_manual(values = c("yellow","red"), name = "Language")
ggplotly(pp)
```

This plot has only scratched the surface. There is a lot more to learn about [plot.ly](https://plot.ly). I encourage you to head on over to their website and check out the growing documentation on the R API. 

