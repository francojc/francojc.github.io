<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reproducible Research on francojc ⟲</title>
    <link>/tags/reproducible-research/</link>
    <description>Recent content in Reproducible Research on francojc ⟲</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jerid Francom</copyright>
    <lastBuildDate>Fri, 20 Oct 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/reproducible-research/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Acquiring data for language research (1/3): direct downloads</title>
      <link>/2017/10/20/acquiring-data-for-language-research-direct-downloads/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/10/20/acquiring-data-for-language-research-direct-downloads/</guid>
      <description>&lt;link href=&#34;/rmarkdown-libs/pagedtable/css/pagedtable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/pagedtable/js/pagedtable.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;There are three main ways to acquire corpus data using R that I will introduce you to: &lt;strong&gt;direct download&lt;/strong&gt;, &lt;strong&gt;package interfaces&lt;/strong&gt;, and &lt;strong&gt;web scraping&lt;/strong&gt;. In this post we will start by directly downloading a corpus as it is the most straightforward process for the novice R programmer and incurs the least number of steps. Along the way I will introduce some key R coding concepts including control statements and custom functions.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The following code is available on GitHub &lt;code&gt;recipes-acquiring_data&lt;/code&gt; and is built on the &lt;code&gt;recipes-project_template&lt;/code&gt; I have discussed in detail &lt;a href=&#34;https://francojc.github.io/2017/08/31/project-management-for-scalable-data-analysis/&#34;&gt;here&lt;/a&gt; and made accessible &lt;a href=&#34;https://github.com/francojc/recipes-project_template.git&#34;&gt;here&lt;/a&gt;. I encourage you to follow along by downloading the &lt;code&gt;recipes-project_template&lt;/code&gt; with &lt;code&gt;git&lt;/code&gt; from the Terminal or create a new RStudio R Project and select the “Version Control” option.&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&#34;direct-downloads&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Direct downloads&lt;/h2&gt;
&lt;p&gt;Published corpus data found in repositories or individual sources are usually the easiest to start working with as it is generally a matter of identifying a resource to download and then downloading it with R. OK, there’s a little more involved, but that’s the basic idea.&lt;/p&gt;
&lt;p&gt;Let’s take a look at how this works starting with the a sample from the Switchboard Corpus, a corpus of 2,400 telephone conversations by 543 speakers. First we navigate to the site with a browser and download the file that we are looking for. In this case I found the Switchboard Corpus on the &lt;a href=&#34;http://www.nltk.org/nltk_data/&#34;&gt;NLTK data repository site&lt;/a&gt;. More often than not this file will be some type of compressed archive file with an extension such as &lt;code&gt;.zip&lt;/code&gt; or &lt;code&gt;.tz&lt;/code&gt;, which is the case here. Archive files make downloading multiple files easy by grouping files and directories into one file. In R we can used the &lt;code&gt;download.file()&lt;/code&gt; function from the base R library&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. There are a number of &lt;strong&gt;arguments&lt;/strong&gt; that a function may require or provide optionally. The &lt;code&gt;download.file()&lt;/code&gt; function minimally requires two: &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;destfile&lt;/code&gt;. That is the file to download and the location where it is to be saved to disk.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download .zip file and write to disk
download.file(url = &amp;quot;https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/packages/corpora/switchboard.zip&amp;quot;, destfile = &amp;quot;data/original/switchboard.zip&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once an archive file is downloaded, however, the file needs to be ‘decompressed’ to reveal the file structure. The file we downloaded is located on our disk at &lt;code&gt;data/original/switchboard.zip&lt;/code&gt;. To decompress this file we use the &lt;code&gt;unzip()&lt;/code&gt; function with the arguments &lt;code&gt;zipfile&lt;/code&gt; pointing to the &lt;code&gt;.zip&lt;/code&gt; file and &lt;code&gt;exdir&lt;/code&gt; specifying the directory where we want the files to be extracted to.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;I encourage you to use the &lt;code&gt;TAB&lt;/code&gt; key to expand the list of options of a function to avoid having to remember the arguments of a function and also to avoid typos. After typing the name of the function and opening &lt;code&gt;(&lt;/code&gt; hit &lt;code&gt;TAB&lt;/code&gt; to view and select the argument(s) you want. Furthermore, the &lt;code&gt;TAB&lt;/code&gt; key can also help you expand paths to files and directories. Note that the expansion will default to the current working directory.&lt;/p&gt;

&lt;/div&gt;

&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Decompress .zip file and extract to our target directory
unzip(zipfile = &amp;quot;data/original/switchboard.zip&amp;quot;, exdir = &amp;quot;data/original/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The directory structure of &lt;code&gt;data/&lt;/code&gt; now should look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data/
├── derived
└── original
    ├── switchboard
    │   ├── README
    │   ├── discourse
    │   ├── disfluency
    │   ├── tagged
    │   ├── timed-transcript
    │   └── transcript
    └── switchboard.zip

3 directories, 7 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point we have acquired the data programmatically and with this code as part of our workflow anyone could run this code and reproduce the same results. The code as it is, however, is not ideally efficient. Firstly the &lt;code&gt;switchboard.zip&lt;/code&gt; file is not strictly needed after we decompress it and it occupies disk space if we keep it. And second, each time we run this code the file will be downloaded from the remote serve leading to unnecessary data transfer and server traffic. Let’s tackle each of these issues in turn.&lt;/p&gt;
&lt;p&gt;To avoid writing the &lt;code&gt;switchboard.zip&lt;/code&gt; file to disk (long-term) we can use the &lt;code&gt;tempfile()&lt;/code&gt; function to open a temporary holding space for the file. This space can then be used to store the file, unzip it, and then the temporary file will be destroyed. We assign the temporary space to an R object we will name &lt;code&gt;temp&lt;/code&gt; with the &lt;code&gt;tempfile()&lt;/code&gt; function. This object can now be used as the value of the argument &lt;code&gt;destfile&lt;/code&gt; in the &lt;code&gt;download.file()&lt;/code&gt; function. Let’s also assign the web address to another object &lt;code&gt;url&lt;/code&gt; which we will use as the value of the &lt;code&gt;url&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create a temporary file space for our .zip file
temp &amp;lt;- tempfile()
# Assign our web address to `url`
url &amp;lt;- &amp;quot;https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/packages/corpora/switchboard.zip&amp;quot;
# Download .zip file and write to disk
download.file(url, temp)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;In the previous code I’ve used the values stored in the objects &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;temp&lt;/code&gt; in the &lt;code&gt;download.file()&lt;/code&gt; function without specifying the argument names –only providing the names of the objects. R will assume that values of a function map to the ordering of the arguments. If your values do not map to ordering of the arguments you are required to specify the argument name and the value. To view the ordering of objects hit &lt;code&gt;TAB&lt;/code&gt; after entering the function name or consult the function documentation by prefixing the function name with &lt;code&gt;?&lt;/code&gt; and hitting &lt;code&gt;ENTER&lt;/code&gt;.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;At this point our downloaded file is stored temporarily on disk and can be accessed and decompressed to our target directory using &lt;code&gt;temp&lt;/code&gt; as the value for the argument &lt;code&gt;zipfile&lt;/code&gt; from the &lt;code&gt;unzip()&lt;/code&gt; function. I’ve assigned our target directory path to &lt;code&gt;target_dir&lt;/code&gt; and used it as the value for the argument &lt;code&gt;exdir&lt;/code&gt; to prepare us for the next tweak on our approach.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Assign our target directory to `target_dir`
target_dir &amp;lt;- &amp;quot;data/original/&amp;quot;
# Decompress .zip file and extract to our target directory
unzip(zipfile = temp, exdir = target_dir)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our directory structure now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data/
├── derived
└── original
    └── switchboard
        ├── README
        ├── discourse
        ├── disfluency
        ├── tagged
        ├── timed-transcript
        └── transcript

3 directories, 6 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second issue I raised concerns the fact that running this code as part of our project will repeat the download each time. Since we would like to be good citizens and avoid unnecessary traffic on the web it would be nice if our code checked to see if we already have the data on disk and if it exists, then skip the download, if not then download it. To achieve this we need to introduce two new functions &lt;code&gt;if()&lt;/code&gt; and &lt;code&gt;dir.exists()&lt;/code&gt;. &lt;code&gt;dir.exists()&lt;/code&gt; takes a path to a directory as an argument and returns the logical value, &lt;code&gt;TRUE&lt;/code&gt;, if that directory exists, and &lt;code&gt;FALSE&lt;/code&gt; if it does not. &lt;code&gt;if()&lt;/code&gt; evaluates logical statements and processes subsequent code based on the logical value it is passed as an argument. Let’s look at a toy example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;num &amp;lt;- 1
if(num == 1) { 
  cat(num, &amp;quot;is 1&amp;quot;) 
  } else {
  cat(num, &amp;quot;is not 1&amp;quot;)
  }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1 is 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I assigned &lt;code&gt;num&lt;/code&gt; to the value &lt;code&gt;1&lt;/code&gt; and created a logical evaluation &lt;code&gt;num ==&lt;/code&gt; whose result is passed as the argument to &lt;code&gt;if()&lt;/code&gt;. If the statement returns &lt;code&gt;TRUE&lt;/code&gt; then the code withing the first set of curly braces &lt;code&gt;{...}&lt;/code&gt; is run. If &lt;code&gt;num == 1&lt;/code&gt; is false, like in the code below, the code withing the braces following the &lt;code&gt;else&lt;/code&gt; will be run.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;num &amp;lt;- 2
if(num == 1) { 
  cat(num, &amp;quot;is 1&amp;quot;) 
  } else {
  cat(num, &amp;quot;is not 1&amp;quot;)
  }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2 is not 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;if()&lt;/code&gt; is one of various functions that are called &lt;strong&gt;control statements&lt;/strong&gt;. Theses functions provide a lot of power to make dynamic choices as code is run.&lt;/p&gt;
&lt;p&gt;Before we get back to our key objective to avoid downloading resources that we already have on disk, let me introduce another strategy to making code more powerful and ultimately more efficient and as well as more legible –the &lt;strong&gt;custom function&lt;/strong&gt;. Custom functions are functions that the user writes to create a set of procedures that can be run in similar contexts. I’ve created a custom function named &lt;code&gt;eval_num()&lt;/code&gt; below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num &amp;lt;- function(num) {
  if(num == 1) { 
  cat(num, &amp;quot;is 1&amp;quot;) 
  } else {
  cat(num, &amp;quot;is not 1&amp;quot;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s take a closer look at what’s going on here. The function &lt;code&gt;function()&lt;/code&gt; creates a function in which the user decides what arguments are necessary for the code to perform its task. In this case the only necessary argument is the object to store a numeric value to be evaluated. I’ve called it &lt;code&gt;num&lt;/code&gt; because it reflects the name of the object in our toy example, but there is nothing special about this name. It’s only important that the object names be consistently used. I’ve included our previous code (except for the hard-coded assignment of &lt;code&gt;num&lt;/code&gt;) inside the curly braces and assigned the entire code chunk to &lt;code&gt;eval_num&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can now use the function &lt;code&gt;eval_num()&lt;/code&gt; to perform the task of evaluating whether a value of &lt;code&gt;num&lt;/code&gt; is or is not equal to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num(num = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1 is 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num(num = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2 is not 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num(num = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3 is not 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’ve put these coding strategies together with our previous code in a function I named &lt;code&gt;get_zip_data()&lt;/code&gt;. There is a lot going on here. Take a look first and see if you can follow the logic involved given what you now know.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_zip_data &amp;lt;- function(url, target_dir) {
  # Function: to download and decompress a .zip file to a target directory
  
  # Check to see if the data already exists
  if(!dir.exists(target_dir)) { # if data does not exist, download/ decompress
    cat(&amp;quot;Creating target data directory \n&amp;quot;) # print status message
    dir.create(path = target_dir, recursive = TRUE, showWarnings = FALSE) # create target data directory
    cat(&amp;quot;Downloading data... \n&amp;quot;) # print status message
    temp &amp;lt;- tempfile() # create a temporary space for the file to be written to
    download.file(url = url, destfile = temp) # download the data to the temp file
    unzip(zipfile = temp, exdir = target_dir, junkpaths = TRUE) # decompress the temp file in the target directory
    cat(&amp;quot;Data downloaded! \n&amp;quot;) # print status message
  } else { # if data exists, don&amp;#39;t download it again
    cat(&amp;quot;Data already exists \n&amp;quot;) # print status message
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK. You should have recognized the general steps in this function: the argument &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;target_dir&lt;/code&gt; specify where to get the data and where to write the decompressed files, the &lt;code&gt;if()&lt;/code&gt; statement evaluates whether the data already exists, if not (&lt;code&gt;!dir.exists(target_dir)&lt;/code&gt;) then the data is downloaded and decompressed, if it does exist (&lt;code&gt;else&lt;/code&gt;) then it is not downloaded.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The prefixed &lt;code&gt;!&lt;/code&gt; in the logical expression &lt;code&gt;dir.exists(target_dir)&lt;/code&gt; returns the opposite logical value. This is needed in this case so when the target directory exists, the expression will return &lt;code&gt;FALSE&lt;/code&gt;, not &lt;code&gt;TRUE&lt;/code&gt;, and therefore not proceed in downloading the resource.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;There are a couple key tweaks I’ve added that provide some additional functionality. For one I’ve included the function &lt;code&gt;dir.create()&lt;/code&gt; to create the target directory where the data will be written. I’ve also added an additional argument to the &lt;code&gt;unzip()&lt;/code&gt; function, &lt;code&gt;junkpaths = TRUE&lt;/code&gt;. Together these additions allow the user to create an arbitrary directory path where the files, and only the files, will be extracted to on our disk. This will discard the containing directory of the &lt;code&gt;.zip&lt;/code&gt; file which can be helpful when we want to add multiple &lt;code&gt;.zip&lt;/code&gt; files to the same target directory.&lt;/p&gt;
&lt;p&gt;A practical scenario where this applies is when we want to download data from a corpus that is contained in multiple &lt;code&gt;.zip&lt;/code&gt; files but still maintain these files in a single primary data directory. Take for example the &lt;a href=&#34;http://www.linguistics.ucsb.edu/research/santa-barbara-corpus&#34;&gt;Santa Barbara Corpus&lt;/a&gt;. This corpus resource includes a series of interviews in which there is one &lt;code&gt;.zip&lt;/code&gt; file, &lt;code&gt;SBCorpus.zip&lt;/code&gt; which contains the &lt;a href=&#34;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/SBCorpus.zip&#34;&gt;transcribed interviews&lt;/a&gt; and another &lt;code&gt;.zip&lt;/code&gt; file, &lt;code&gt;metadata.zip&lt;/code&gt; which organizes the &lt;a href=&#34;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/metadata.zip&#34;&gt;meta-data&lt;/a&gt; associated with each speaker. Applying our initial strategy to download and decompress the data will lead to the following directory structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    ├── SBCorpus
    │   ├── TRN
    │   └── __MACOSX
    │       └── TRN
    └── metadata
        └── __MACOSX

8 directories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By applying our new custom function &lt;code&gt;get_zip_data()&lt;/code&gt; to the transcriptions and then the meta-data we can better organize the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download corpus transcriptions
get_zip_data(url = &amp;quot;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/SBCorpus.zip&amp;quot;, target_dir = &amp;quot;data/original/sbc/transcriptions/&amp;quot;)

# Download corpus meta-data
get_zip_data(url = &amp;quot;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/metadata.zip&amp;quot;, target_dir = &amp;quot;data/original/sbc/meta-data/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now our &lt;code&gt;data/&lt;/code&gt; directory is better organized; both the transcriptions and the meta-data are housed under &lt;code&gt;data/original/sbc/&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    └── sbc
        ├── meta-data
        └── transcriptions

5 directories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we add data from other sources we can keep them logical separate and allow our data collection to scale without creating unnecessary complexity. Let’s add the Switchboard Corpus sample using our &lt;code&gt;get_zip_data()&lt;/code&gt; function to see this in action.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download corpus
get_zip_data(url = &amp;quot;https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/packages/corpora/switchboard.zip&amp;quot;, target_dir = &amp;quot;data/original/scs/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our corpora our housed in their own directories and the files are clearly associated.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    ├── sbc
    │   ├── meta-data
    │   └── transcriptions
    └── scs

6 directories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point we have what we need to continue to the next step in our data analysis project. But before we go, we should do some housekeeping to document and organize this process to make our work reproducible. We will take advantage of the &lt;code&gt;project-template&lt;/code&gt; directory structure, seen below.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── README.md
├── _pipeline.R
├── code
│   ├── acquire_data.R
│   ├── analyze_data.R
│   ├── curate_data.R
│   ├── generate_reports.R
│   └── transform_data.R
├── data
│   ├── derived
│   └── original
├── figures
├── functions
├── log
├── recipes-acquire-data.Rproj
└── report
    ├── article.Rmd
    ├── bibliography.bib
    ├── slides.Rmd
    └── web.Rmd

8 directories, 13 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First it is good practice to separate custom functions from our processing scripts. We can create a file in our &lt;code&gt;functions/&lt;/code&gt; directory named &lt;code&gt;acquire_functions.R&lt;/code&gt; and add our custom function &lt;code&gt;get_zip_data()&lt;/code&gt; there. We then use the &lt;code&gt;source()&lt;/code&gt; function to read that function into our current script to make it available to use as needed. It is good practice to source your functions in the SETUP section of your script.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Load custom functions for this project
source(file = &amp;quot;functions/acquire_functions.R&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Second it is advisable to log the structure of the data in plain text files. You can create a directory tree (as those seen in this post) with the bash command &lt;code&gt;tree&lt;/code&gt; on the command line. R provides a function &lt;code&gt;system()&lt;/code&gt; which will interface the command line. Adding the following code to the LOG section of your &lt;code&gt;acquire_data.R&lt;/code&gt; R script will generate the directory structure for each of the corpora that we have downloaded in this post in the files &lt;code&gt;data_original_sbc.log&lt;/code&gt; and &lt;code&gt;data_original_scs.log&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Log the directory structure of the Santa Barbara Corpus
system(command = &amp;quot;tree data/original/sbc &amp;gt;&amp;gt; log/data_original_sbc.log&amp;quot;)
# Log the directory structure of the Switchboard Corpus sample
system(command = &amp;quot;tree data/original/scs &amp;gt;&amp;gt; log/data_original_scs.log&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our project directory structure now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── README.md
├── _pipeline.R
├── code
│   ├── acquire_data.R
│   ├── analyze_data.R
│   ├── curate_data.R
│   ├── generate_reports.R
│   └── transform_data.R
├── data
│   ├── derived
│   └── original
├── figures
├── functions
│   └── acquire_functions.R
├── log
│   ├── data_original_sbc.log
│   └── data_original_scs.log
├── recipes-acquire-data.Rproj
└── report
    ├── article.Rmd
    ├── bibliography.bib
    ├── slides.Rmd
    └── web.Rmd

8 directories, 15 files&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;round-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Round up&lt;/h2&gt;
&lt;p&gt;In this post we’ve covered how to access, download, and organize data contained in .zip files; the most common format for language data found on repositories and individual sites. This included an introduction to a few key R programming concepts and strategies including using functions, writing custom functions, and controlling program flow with control statements. Our approach was to gather data while also keeping in mind the reproducibility of the code. To this end I introduced programming strategies for avoiding unnecessary web traffic (downloads), scalable directory creation, and data documentation.&lt;/p&gt;
&lt;p&gt;In the next post in this three part mini-series I will cover acquiring data from web services such as Project Gutenberg, Twitter, and Facebook through R packages. Using package interfaces will require additional knowledge of R objects. I will discuss vector types and data frames and show how to manipulate these objects in practical situations like filtering data and writing data to disk in plain-text files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Remember base R packages are installed by default with R and are loaded and accessible by default in each R session.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Project management for scalable data analysis</title>
      <link>/2017/08/31/project-management-for-scalable-data-analysis/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/08/31/project-management-for-scalable-data-analysis/</guid>
      <description>&lt;div id=&#34;project-management&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Project management&lt;/h2&gt;
&lt;p&gt;This post can really be seen as an extension of the last post &lt;a href=&#34;https://francojc.github.io/2017/08/14/getting-started-with-r-and-rstudio/&#34;&gt;Getting started with R and RStudio&lt;/a&gt; in that we will be getting to know some more advanced, but indispensable features of RStudio. These features, in combination with some organizational and programming strategies, will enable us to conduct efficient data analysis and set the stage for research is is both scalable and ready for sharing with either collaborators or the research community.&lt;/p&gt;
&lt;p&gt;To understand the value of this approach to project management we need to get a bird’s eye view of the key steps in a data science project. There are three main areas that any research project includes: &lt;strong&gt;data organization&lt;/strong&gt;, &lt;strong&gt;data analysis&lt;/strong&gt;, and &lt;strong&gt;reporting results&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;These three main areas have important subareas as well:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Data organization:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;acquiring data&lt;/em&gt; whether that be from a database or through a download or webscrape&lt;/li&gt;
&lt;li&gt;&lt;em&gt;curating data&lt;/em&gt; so that it will be reliable for subsequent steps in the process&lt;/li&gt;
&lt;li&gt;&lt;em&gt;transforming the data&lt;/em&gt; into a format that will facilitate the analysis of the data including the generation of new variables and measures.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Data analysis:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;visualizing data&lt;/em&gt; in summary tables and graphics to gain a better sense of the distribution of the question that we are aiming to learn about.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;statistical tests&lt;/em&gt; to provide confirmation of the distribution(s) that we are investigating and/or a more robust understanding of the relationships between variables in our data&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Reporting results:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Communicating findings&lt;/em&gt; in an appropriate format for the venue. This can be standard article format, or slides, or as a webpage.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Preparing reproducible results&lt;/em&gt; by ensuring that our work is well documented and capable of being replicated&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By taking these steps into account in the organization of our project, we will be able to work more efficiently and effectively with R and RStudio. In the next section we will get set up with a model template for organizing a data science project. This structure will serve as our base for working in subsequent posts in this series.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;project-structure&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Project structure&lt;/h2&gt;
&lt;p&gt;As a starting point, we will download an existing project that I have created. This project will work as a template for implementing good project management with RStudio. The project template is housed remotely on the code sharing platform &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; which leverages the &lt;a href=&#34;https://git-scm.com/&#34;&gt;&lt;code&gt;git&lt;/code&gt; versioning software&lt;/a&gt; to make local projects remotely accessible. After copying the project to your local machine, we will link RStudio to the project and continue our exploration of the various features available in this software to manage projects.&lt;/p&gt;
&lt;div id=&#34;downloading-the-template&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Downloading the template&lt;/h3&gt;
&lt;p&gt;To download this project template, we will need to set up &lt;code&gt;git&lt;/code&gt; on your machine first. I will have much more to say about &lt;code&gt;git&lt;/code&gt; and GitHub in a later post in the series that will directly concern the process of versioning and sharing reproducible research, but for now we’ll only cover what is needed to get our project template from GitHub. If you are on a Mac, &lt;code&gt;git&lt;/code&gt; is most likely already on your machine. To verify that this is the case you can open up the ‘Terminal.app’ on your machine and type this command at the prompt:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;which git&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The ‘Terminal.app’ on Mac, ‘Terminal’ on Linux, and ‘git bash’ on Windows all interface what is called the ‘Shell’, or &lt;a href=&#34;https://en.wikipedia.org/wiki/Command-line_interface&#34;&gt;command-line interface&lt;/a&gt;. This is a interface to your computer not unlike the Console is to R in the R GUI Application or RStudio. There are various environments with particular syntax conventions for working with your computer through this interface, the most common being the ‘Bash’ shell. I encourage you to learn some the &lt;a href=&#34;https://www.davidbaumgold.com/tutorials/command-line/&#34;&gt;basics of using the command-line&lt;/a&gt;.&lt;br /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;If &lt;code&gt;git&lt;/code&gt; is already installed, then a path to this software, similar to the one below, will be returned.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;/usr/local/bin/git&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a path is not returned, or you are on a PC, then you will need to download and install the software from the &lt;code&gt;git&lt;/code&gt; homepage. Follow this &lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;link to the &lt;code&gt;git&lt;/code&gt; downloads page&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:git-install-1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-08-31-project-management-for-scalable-data-analysis_files/figure-html/git-install-1-1.png&#34; alt=&#34;Git downloads page.&#34; width=&#34;100%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Git downloads page.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Download the installer for you operating system and run this installer with the default installation recommendations.&lt;/p&gt;
&lt;p&gt;Now that you have &lt;code&gt;git&lt;/code&gt; on your machine, let’s set some global options that will personalize your software while since we are already working at the command line. If you are on a Mac or Linux, open the ‘Terminal’. If you are on a Windows machine, navigate to the programs menu and open ‘git bash’.&lt;/p&gt;
&lt;p&gt;At the terminal, enter the following commands –replacing ‘Your Name’ and ‘your@email.com’ with your information.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;git config --global user.name &amp;#39;Your Name&amp;#39;
git config --global user.email &amp;#39;your@email.com&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, let’s download the project, ‘recipes-project_template’ from &lt;a href=&#34;https://github.com/francojc?tab=repositories&#34;&gt;my personal GitHub repository&lt;/a&gt;. To do this, you will want to first decide where on your machine you will like to store this project. If you are following the Recipe series, I recommend that you create a new directory called &lt;code&gt;Recipes/&lt;/code&gt; somewhere convenient on your hard disk. You can then use this directory to house this and other upcoming projects associated with posts in this series.&lt;/p&gt;
&lt;p&gt;To create this directory, I’ll use the &lt;code&gt;mkdir&lt;/code&gt; command, or ‘make directory’. The &lt;code&gt;~&lt;/code&gt; is a shortcut operator for the current users home directory. On my Mac the full path would be &lt;code&gt;/Users/francojc/Documents/Recipes/&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;mkdir ~/Documents/Recipes/&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Quick tip: When typing a path at the command line you can start typing a directory name and hit the &lt;code&gt;tab&lt;/code&gt; key on your keyboard to autofill the full name. If you hit &lt;code&gt;tab&lt;/code&gt; twice in a row, the &lt;code&gt;bash&lt;/code&gt; shell will list the available subdirectory paths. This can speed up navigation at the command line and help avoid typographical errors.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;Once we have created the main directory &lt;code&gt;Recipes/&lt;/code&gt; to house the repository, we need to navigate to that directory using &lt;code&gt;cd&lt;/code&gt;, or ‘change directory’.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cd ~/Documents/Recipes/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Verify that your current working directory is correct by entering &lt;code&gt;pwd&lt;/code&gt;, or ‘path to working directory’ to get the current directory’s path.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result should print the path to your &lt;code&gt;Recipes/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;Now we are ready to use &lt;code&gt;git&lt;/code&gt; to copy the remote project from my GitHub repository &lt;code&gt;recipes-project_template&lt;/code&gt; to our current directory. Enter the following command at the terminal prompt.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;git clone https://github.com/francojc/recipes-project_template.git&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should get some information about the download, or clone, that looks something similar to the output below.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cloning into &amp;#39;recipes-project_template&amp;#39;...
remote: Counting objects: 48, done.
remote: Compressing objects: 100% (27/27), done.
remote: Total 48 (delta 21), reused 38 (delta 15), pack-reused 0
Unpacking objects: 100% (48/48), done.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;recipes-project_template/&lt;/code&gt; directory that you just cloned into your &lt;code&gt;Recipes/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;You can now inspect the new directory, subdirectories, and files that now reside in the &lt;code&gt;recipes-project_template/&lt;/code&gt; directory with either at the command line, or with your operating systems file explorer. At the command line you can use the &lt;code&gt;ls&lt;/code&gt;, or ‘list structure’ command like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see the following output.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;README.md   code        figures     log
_pipeline.R data        functions   report&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now leave the Terminal, or git bash, and return to RStudio. We are now ready to link an R project to our cloned project.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;creating-an-r-project-within-rstudio&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Creating an R Project within RStudio&lt;/h3&gt;
&lt;p&gt;As we have seen, RStudio provides a of host tools for facilitating work with R. A feature that makes working with the sometimes numerous data files, scripts, and other resources more manageable is the ‘R Project’ tool. In a nutshell, this RStudio tool allows us to select a directory where our project files live and effectively group these files and the work we do as a unit. At a basic level it simply helps manage individual projects more easily. As we move on to other posts in this series, and particularly when we discuss creating reproducible research, we will see that this feature will really prove its worth. For now, let’s make the project template an R project and turn to focus on the file and directory structure as it relates to doing efficient and reproducible data analysis in R.&lt;/p&gt;
&lt;p&gt;To link our template to an R Project, start up R and select the ‘New Project…’ dialogue from the RStudio toolbar menu. You will be presented with various options as seen in Figure &lt;a href=&#34;#fig:r-project-1&#34;&gt;2&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:r-project-1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-08-31-project-management-for-scalable-data-analysis_files/figure-html/r-project-1-1.png&#34; alt=&#34;Options for creating an R Project in RStudio.&#34; width=&#34;400&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Options for creating an R Project in RStudio.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The first option is for starting a project from scratch. The last option is for cloning a project from a versioning repository like GitHub. With versioning software, like &lt;code&gt;git&lt;/code&gt;, on our machine, we can clone and create an R Project in one step. We will make use of this option in future posts now that we have a basic understand of &lt;code&gt;git&lt;/code&gt; and GitHub. For now, however, we want to link the project template we cloned manually using the command line, so select ‘Existing Directory’ from this menu.&lt;/p&gt;
&lt;p&gt;Next navigate to the directory which we cloned either typing the path to the directory, or more conveniently using the ‘Browse’ button. Once we have selected the directory and create the R Project, RStudio will open a new session with our directories and files listed in the Files pane.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:r-project-2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-08-31-project-management-for-scalable-data-analysis_files/figure-html/r-project-2-1.png&#34; alt=&#34;View of the project template as an R Project.&#34; width=&#34;100%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: View of the project template as an R Project.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You will notice that RStudio has created a file named &lt;code&gt;recipes-project_template.Rproj&lt;/code&gt;. From now on you can navigate to this file using your operating system’s file explorer and open it to return working on this project. Your workspace settings, history, environment variables, etc. will be restored to the last time you were working on the project –more on this later.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;saffolding-for-a-scalable-project&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Saffolding for a scalable project&lt;/h2&gt;
&lt;p&gt;Now let’s turn to the files and directories of our project template and discuss how this structure is associated to the steps listed earlier to conduct a data science project. Below you will see the complete structure of the template.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── README.md
├── _pipeline.R
├── code/
│   ├── acquire_data.R
│   ├── analyze_data.R
│   ├── curate_data.R
│   ├── generate_reports.R
│   └── transform_data.R
├── data/
│   ├── derived/
│   └── original/
├── figures/
├── functions/
├── log/
├── recipes-project_template.Rproj
└── report/
    ├── article.Rmd
    ├── bibliography.bib
    ├── slides.Rmd
    └── web.Rmd&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;directories&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Directories&lt;/h3&gt;
&lt;p&gt;This template includes directories for data (&lt;code&gt;data&lt;/code&gt;), code (&lt;code&gt;code&lt;/code&gt;), and communicating findings (&lt;code&gt;report&lt;/code&gt;). These directories are core to your project and where the heavy lifting takes place. The &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;report&lt;/code&gt; directories have important subdirectories that separate key stages in your analysis. &lt;code&gt;data/original&lt;/code&gt; is where the data in its raw form will be stored and &lt;code&gt;data/derived&lt;/code&gt; is where any changes you make to the data for the particular analysis are stored. This distinction is an important one; to safeguard our analysis and to ensure that our analysis is reproducible we do not want to make changes to the original data that are not reflected in the project itself. The subdirectories of &lt;code&gt;report&lt;/code&gt; separate the potential formats that we may use to communicate insight generated from this analysis.&lt;/p&gt;
&lt;p&gt;Before moving on to discuss the files included in the template, let’s discuss the other three supporting directories: &lt;code&gt;figures&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, and &lt;code&gt;functions&lt;/code&gt;. You will most likely generate figures in the course of the analysis. Grouping them together in the &lt;code&gt;figures&lt;/code&gt; directory enables us to quickly reference them visually and also include them in any one or all of the reports that may be generated. The &lt;code&gt;log&lt;/code&gt; directory is a convenient and easily identifiable place to document meta aspects of your analysis that will may not picture in your reports. Finally, a directory for housing custom functions you may write to facilitate particular stages of the analysis is provided, &lt;code&gt;functions&lt;/code&gt;. We will soon see how powerful and indispensable custom functions are but for now just let me say that keeping them organized in a separate directory will enhance the legibility of your code and help you take full advantage of their power.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;files&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Files&lt;/h3&gt;
&lt;p&gt;This template also includes various file templates that are associated with the tasks typically performed in a data analysis project. The R scripts in the &lt;code&gt;code/&lt;/code&gt; directory are script templates to carry out the sub-tasks of our three main project steps: organize data; get the original data (&lt;code&gt;acquire_data.R&lt;/code&gt;), clean and prepare key features of the data (&lt;code&gt;curate_data.R&lt;/code&gt;), manipulate the data creating the needed variables and structure for the data analysis (&lt;code&gt;transform_data.R&lt;/code&gt;), data analysis; visualize and perform statistical analyses on the data (&lt;code&gt;analyze_data.R&lt;/code&gt;), and communicating findings; report results in appropriate formats (&lt;code&gt;generate_reports.R&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Each of these R scripts has a common structure which is outlined using code commenting. Take a look at the structure of the &lt;code&gt;acquire_data.R&lt;/code&gt; script, copied below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ABOUT -----------------------------------------------------------

# Description: &amp;lt;The aim of this script&amp;gt;
# Usage: &amp;lt;How to run this script: what input it requires and output produced&amp;gt;
# Author: &amp;lt;Your name&amp;gt;
# Date: &amp;lt;current date&amp;gt;

# SETUP -----------------------------------------------------------

# Script-specific options or packages

# RUN -------------------------------------------------------------

# Steps involved in acquiring and organizing the original data

# LOG -------------------------------------------------------------

# Any descriptives that will be helpful to understand the results of this
# script and how it contributes to the aims of the project

# CLEAN UP --------------------------------------------------------

# Remove all current environment variables
rm(list = ls())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The template shown here leverages code commenting to separate the script into meaningful tasks. The &lt;code&gt;ABOUT&lt;/code&gt; section is where you will provide an overview of the purpose of the script in your project, how to use it, who created it, and when it was created. The &lt;code&gt;SETUP&lt;/code&gt; section provides a space to load any required packages, source any required custom functions, and configure various other options. &lt;code&gt;RUN&lt;/code&gt; is where the bulk of your code will be entered. As it has been stated various times, commenting is a vital part of sound coding practices. It is often helpful not only to comment the particular line of code, which we do by adding the &lt;code&gt;#&lt;/code&gt; symbol to the immediate right of the code and then describe the task, but also to group coding sub-tasks in this section. RStudio provides a tool to create comment sections. You can use this tool by selecting ‘Code &amp;gt; Insert Section…’ or the keyboard shortcut &lt;code&gt;shift + command + R&lt;/code&gt; (Mac) or &lt;code&gt;shift + ctrl + R&lt;/code&gt; (PC). Either approach will trigger a dialogue box to enter the name of the section. Once you have entered the name it will then appear in the section listing, as seen in Figure &lt;a href=&#34;#fig:r-project-3&#34;&gt;4&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:r-project-3&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-08-31-project-management-for-scalable-data-analysis_files/figure-html/r-project-3-1.png&#34; alt=&#34;View of the section listing in RStudio.&#34; width=&#34;100%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 4: View of the section listing in RStudio.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You can use this listing to skip from section to section which can be very helpful as your script becomes more complicated with subsequent code.&lt;/p&gt;
&lt;p&gt;The last two sections &lt;code&gt;LOG&lt;/code&gt; and &lt;code&gt;CLEANUP&lt;/code&gt; are good-housekeeping sections. &lt;code&gt;LOG&lt;/code&gt; is where you can divert any meta-information about the analysis to the &lt;code&gt;log/&lt;/code&gt; directory. This is an important step to take at this point as the last section, &lt;code&gt;CLEANUP&lt;/code&gt;, is where you will remove any of the objects your script has created with the &lt;code&gt;rm(list = ls()&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;Although removing objects created is not strictly required, it has two key benefits: it will free up any memory that these objects claim from our R session and it helps keep each script as modular as possible. Freeing up memory after an object is no longer needed is good practice as memory handling in R is not one of the language’s strong points. Striving for modularity speaks more to reproducibility and analysis workflow. If a subsequent step relies on an object generated by a previous script that is held in memory, we must run the previous script in the workflow each time before the next. As the number of tasks increases and as these tasks become more processing intensive, it will lead to an unnecessary loss of computing resources and time. To avoid this scenario, each script in our analysis should only require input that is read from an session-external source; that is from a resource online or from the hard disk. This means that if an object created in a script will be needed a some point in our analysis, it should be written to disk –preferably in a plain-text version.&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The last of the three main steps in a data analysis project, ‘Reporting results’, is associated with the file &lt;code&gt;generate_reports.R&lt;/code&gt; in the &lt;code&gt;code/&lt;/code&gt; directory which is tied to the various files in the &lt;code&gt;report/&lt;/code&gt; directory. These later files have the extension &lt;code&gt;.Rmd&lt;/code&gt;, not &lt;code&gt;.R&lt;/code&gt;. This distinction reflects the fact that these files are a special type of R script: an &lt;a href=&#34;http://rmarkdown.rstudio.com/&#34;&gt;RMarkdown script&lt;/a&gt;. RMarkdown is a variant of the popular markup language &lt;a href=&#34;https://en.wikipedia.org/wiki/Markdown&#34;&gt;Markdown&lt;/a&gt;. RMarkdown goes beyond standard Markdown documents in that they allow for the intermingling of code, prose, and graphics to dynamically create reports in &lt;a href=&#34;http://rmarkdown.rstudio.com/pdf_document_format.html&#34;&gt;PDF document format&lt;/a&gt; (&lt;code&gt;report/article/report.Rmd&lt;/code&gt;), &lt;a href=&#34;http://rmarkdown.rstudio.com/ioslides_presentation_format.html&#34;&gt;presentation slides&lt;/a&gt; (&lt;code&gt;report/slides/presentation.Rmd&lt;/code&gt;), and &lt;a href=&#34;http://rmarkdown.rstudio.com/html_document_format.html&#34;&gt;interactive web pages&lt;/a&gt; (&lt;code&gt;report/web/webpage.Rmd&lt;/code&gt;). Data and figures generated in by the R scripts in your analysis can be included in these documents along with citations and a corresponding bibliography sourced from a Bibtex file &lt;code&gt;report/bibliography.bib&lt;/code&gt;.&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Together these features a provide powerful tool belt for creating publication quality reports. The &lt;code&gt;generate_reports.R&lt;/code&gt; file simply runs the commands to render these files in their specific formats.&lt;/p&gt;
&lt;p&gt;I have provided rough outlines for each of these RMarkdown output formats. We will explore the details of creating reports later in the series. But for now, I encourage you to browse the &lt;a href=&#34;http://rmarkdown.rstudio.com/gallery.html&#34;&gt;RMarkdown gallery&lt;/a&gt; and explore the &lt;a href=&#34;http://rmarkdown.rstudio.com/articles.html&#34;&gt;documentation&lt;/a&gt; to get a sense of what RMarkdown can do.&lt;/p&gt;
&lt;p&gt;The last two files in this template are the &lt;code&gt;_pipeline.R&lt;/code&gt; script and the &lt;code&gt;README.md&lt;/code&gt; document. &lt;code&gt;README.md&lt;/code&gt; is the file used to describe the project in general terms including the purpose of the project, data sources, analysis methods, and other relevant information to help clarify how to reproduce the research with these project files. The &lt;code&gt;README&lt;/code&gt; file may or may not include the &lt;code&gt;.md&lt;/code&gt; extension. If it does, as in the example in this template, you will have access to the Markdown syntax options to provide word processing style formatting, if needed. If you end up storing you project on a code repository site, such as GitHub, this file will be rendered as a web document and be used as the introduction to your project.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;_pipeline.R&lt;/code&gt; script is the master script for your analysis. It is a standard R script and includes the same internal commenting sections as the other &lt;code&gt;.R&lt;/code&gt; scripts in the the &lt;code&gt;code/&lt;/code&gt; directory (i.e. &lt;code&gt;ABOUT&lt;/code&gt;, &lt;code&gt;SETUP&lt;/code&gt;, &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;LOG&lt;/code&gt;, and &lt;code&gt;CLEANUP&lt;/code&gt;). This script, however, allows you to run the entire project from data to report in sequential order. In the &lt;code&gt;RUN&lt;/code&gt; section you will find sub-steps which call the &lt;code&gt;source()&lt;/code&gt; function on each of our processing scripts. Since each script representing a step in our analysis is modular, only the required input is read and output generated for each script. As logging step-specific information is taken care of in each particular script, the &lt;code&gt;LOG&lt;/code&gt; section in the &lt;code&gt;_pipeline.R&lt;/code&gt; script will most typically only include a call to the &lt;code&gt;sessionInfo()&lt;/code&gt; function which reports details on the operating system and the packages and the versions of the packages used in the analysis. This information is vital for reproducing research as it documents the specific conditions that successfully generated the analysis.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Quick note: there is nothing special about the names of the files in the template. You can edit and modify these file names as you see fit. You should, however, take note of good file naming practices. Names should be descriptive and short. Whitespace is traditionally avoided, but is not explicitly required. I have employed ‘snake case’ here by using an underscore (&lt;code&gt;_&lt;/code&gt;) to mark spaces in file names. There are various style conventions used to avoid whitespace and for other coding practices. I recommend following the suggestions provided by Hadley Wickham in his book &lt;a href=&#34;http://adv-r.had.co.nz/Style.html&#34;&gt;‘Advanced R’&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(Wickham 2014)&lt;/span&gt;. Whatever style you choose, the most important thing is to be consistent.&lt;/p&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;div id=&#34;r-project-sessions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;R Project sessions&lt;/h3&gt;
&lt;p&gt;Once the files and directories are linked to an R Project your workspace settings, command history, and objects can be saved at any point and restored to continue working on the analysis. To see this in action, let’s do a little work with this project template. Let’s run the &lt;code&gt;_pipeline.R&lt;/code&gt; file. There isn’t much to our analysis at this point, as it is just boilerplate material for the most part, but it will serve to highlight how to work with an R Project session. To run this file, open it from the Files pane. It will appear in the Editor pane where we can now use the keyboard shortcut &lt;code&gt;option + command + R&lt;/code&gt; (Mac) or &lt;code&gt;alt + ctrl + R&lt;/code&gt; (PC) to run the entire master script.&lt;/p&gt;
&lt;p&gt;Once you have run the &lt;code&gt;_pipeline.R&lt;/code&gt; script, some new files will appear in your directory structure, seen below.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── README.md
├── _pipeline.R
├── code/
│   ├── acquire_data.R
│   ├── analyze_data.R
│   ├── curate_data.R
│   ├── generate_reports.R
│   └── transform_data.R
├── data/
│   ├── derived
│   └── original
├── figures/
├── functions/
├── log/
│   └── session_info.txt
├── recipes-project_template.Rproj
└── report/
    ├── article.Rmd
    ├── article.pdf
    ├── bibliography.bib
    ├── slides.Rmd
    ├── slides.html
    ├── web.Rmd
    └── web.html&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new files appear in the &lt;code&gt;log/&lt;/code&gt; and &lt;code&gt;report/&lt;/code&gt; directories. The &lt;code&gt;session_info.txt&lt;/code&gt; file is our log of the session information. The &lt;code&gt;article.pdf&lt;/code&gt;, &lt;code&gt;slides.html&lt;/code&gt;, and &lt;code&gt;web.html&lt;/code&gt; files are the rendered versions of the RMarkdown templates. If you browse to the History tab in the Environment pane you will see that we have one line in our history –the code that ran the &lt;code&gt;_pipeline.R&lt;/code&gt; file. Let’s quit our R session now by closing RStudio. When prompted, choose ‘Save’ from the ‘Quit R session’ dialogue box. Now reopen our R project by either starting RStudio then choosing ‘File &amp;gt; Recent Projects’ in the RStudio toolbar or by navigating to the &lt;code&gt;recipes-project_template.Rproj&lt;/code&gt; file with your operating system’s file explorer and double-clicking it.&lt;/p&gt;
&lt;p&gt;Choosing to save our project before closing RStudio has the effect of taking a snapshot of the current workspace. The files that were open on closing the session are returned to the workspace. Any variables we had in memory and the command history are also returned. The details of this snapshot are stored in the files you will now find at the root of our project directory: &lt;code&gt;.RData&lt;/code&gt; and &lt;code&gt;.Rhistory&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:r-project-4&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-08-31-project-management-for-scalable-data-analysis_files/figure-html/r-project-4-1.png&#34; alt=&#34;View of the R project snapshot files `.RData` and `.Rhistory`.&#34; width=&#34;100%&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 5: View of the R project snapshot files &lt;code&gt;.RData&lt;/code&gt; and &lt;code&gt;.Rhistory&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;You might be wondering why these files are prefixed with &lt;code&gt;.&lt;/code&gt;. Using a period before file names is not specific to RStudio. It is &lt;a href=&#34;https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory&#34;&gt;a convention used in programming to hide a file from system file explorers&lt;/a&gt;. These types of files are often used for configuration and application resources and are not meant to be edited by the average user.&lt;br /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;If you choose not to save the workspace when quitting RStudio, these files will not be generated, if they do not already exist, or they will not be overwritten by the current session if they already exist.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;round-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Round up&lt;/h2&gt;
&lt;p&gt;In this post we have discussed setting up and managing an R Project in RStudio. Along the way I provided a sample template for structuring your data analysis project based on the common steps in data science research. You have seen how this template is associated to each step and learned about some important conventions and guidelines for maintaining an efficient workflow. These principles are fundamental to creating an internally consistent and reproducible project.&lt;/p&gt;
&lt;p&gt;Later on in the series we will discuss project versioning and packaging to make a project fully reproducible for you and future collaborators. We will leave that discussion for now and turn our attention in the next post in the series which addresses one of the main conceptual underpinnings of quantitative research: statistical thinking.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;!-- Ideas for next posts:

* Introduction to statistical thinking
- What is data?
  * Observations
- Informational types
  * The nature of observation
  * Measurements
- Relationships
  * Establishing connections between observations
  * Is a connection reliable?
- Comparisons
  * Generalizing relationships between data collections with similar but unique observationsz

# Sub-task posts

... to working through each of the sub-tasks of the data science workflow focusing on typical contexts and applications for quantitative language and linguistic research. ...

* Acquiring data in R: various sources and types
  - Types of data
    * Curated to uncurated
  - Data sources
    * Locations
    - Files and file types
      * Files and file extensions
      * Plain text
      * Delimited files

* Curating data: cleaning, organizing, and annotating  

* Transforming data: preparing data for analysis  

* Visualization: exploring distributions in graphical and tabular form 

* Analysis:  

* Reporting
  - Creating reports in various formats with RMarkdown
  - Creating reproducible research: project versioning and packaging
    - Project backups, versioning, and sharing
      * git and Github


# Later...




# Book chapters

* Quantitative language research: why does it matter?
- Gains made across the board in quantitative research
- Approaching language research as a quantitative science
- Frequency matters (cognitive rationale for quantitative research)
- Case studies

--&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Wickham2014&#34;&gt;
&lt;p&gt;Wickham, H. 2014. &lt;em&gt;Advanced R&lt;/em&gt;. CRC Press.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Plain text files, in essence, are the &lt;em&gt;lingua franca&lt;/em&gt; of the computing world. They are the type of files that can be readily accessed through a plain-text editor such as ‘TextEdit’ (Mac) or ‘Notepad’ (PC). Importantly these files are not compiled by nor bound to any particular software, such as a document generated by Word or Excel. We will see how to write objects to disk as plain text files in subsequent posts.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;You can &lt;a href=&#34;http://www.bibtex.org/Using/&#34;&gt;generate your own Bibtex file&lt;/a&gt; or generate one using bibliographic management software such as &lt;a href=&#34;https://blog.mendeley.com/2011/10/25/howto-use-mendeley-to-create-citations-using-latex-and-bibtex/&#34;&gt;Mendeley&lt;/a&gt; or &lt;a href=&#34;http://libguides.mit.edu/c.php?g=176000&amp;amp;p=1159208&#34;&gt;Zotero&lt;/a&gt;&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
