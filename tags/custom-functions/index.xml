<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Custom Functions on francojc ⟲</title>
    <link>/tags/custom-functions/</link>
    <description>Recent content in Custom Functions on francojc ⟲</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jerid Francom</copyright>
    <lastBuildDate>Fri, 20 Oct 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/custom-functions/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Acquiring data for language research (1/3): direct downloads</title>
      <link>/2017/10/20/acquiring-data-for-language-research-direct-downloads/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/10/20/acquiring-data-for-language-research-direct-downloads/</guid>
      <description>&lt;link href=&#34;/rmarkdown-libs/pagedtable/css/pagedtable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/pagedtable/js/pagedtable.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;There are three main ways to acquire corpus data using R that I will introduce you to: &lt;strong&gt;direct download&lt;/strong&gt;, &lt;strong&gt;package interfaces&lt;/strong&gt;, and &lt;strong&gt;web scraping&lt;/strong&gt;. In this post we will start by directly downloading a corpus as it is the most straightforward process for the novice R programmer and incurs the least number of steps. Along the way I will introduce some key R coding concepts including control statements and custom functions.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The following code is available on GitHub &lt;code&gt;recipes-acquiring_data&lt;/code&gt; and is built on the &lt;code&gt;recipes-project_template&lt;/code&gt; I have discussed in detail &lt;a href=&#34;https://francojc.github.io/2017/08/31/project-management-for-scalable-data-analysis/&#34;&gt;here&lt;/a&gt; and made accessible &lt;a href=&#34;https://github.com/francojc/recipes-project_template.git&#34;&gt;here&lt;/a&gt;. I encourage you to follow along by downloading the &lt;code&gt;recipes-project_template&lt;/code&gt; with &lt;code&gt;git&lt;/code&gt; from the Terminal or create a new RStudio R Project and select the “Version Control” option.&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&#34;direct-downloads&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Direct downloads&lt;/h2&gt;
&lt;p&gt;Published corpus data found in repositories or individual sources are usually the easiest to start working with as it is generally a matter of identifying a resource to download and then downloading it with R. OK, there’s a little more involved, but that’s the basic idea.&lt;/p&gt;
&lt;p&gt;Let’s take a look at how this works starting with the a sample from the Switchboard Corpus, a corpus of 2,400 telephone conversations by 543 speakers. First we navigate to the site with a browser and download the file that we are looking for. In this case I found the Switchboard Corpus on the &lt;a href=&#34;http://www.nltk.org/nltk_data/&#34;&gt;NLTK data repository site&lt;/a&gt;. More often than not this file will be some type of compressed archive file with an extension such as &lt;code&gt;.zip&lt;/code&gt; or &lt;code&gt;.tz&lt;/code&gt;, which is the case here. Archive files make downloading multiple files easy by grouping files and directories into one file. In R we can used the &lt;code&gt;download.file()&lt;/code&gt; function from the base R library&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. There are a number of &lt;strong&gt;arguments&lt;/strong&gt; that a function may require or provide optionally. The &lt;code&gt;download.file()&lt;/code&gt; function minimally requires two: &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;destfile&lt;/code&gt;. That is the file to download and the location where it is to be saved to disk.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download .zip file and write to disk
download.file(url = &amp;quot;https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/packages/corpora/switchboard.zip&amp;quot;, destfile = &amp;quot;data/original/switchboard.zip&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once an archive file is downloaded, however, the file needs to be ‘decompressed’ to reveal the file structure. The file we downloaded is located on our disk at &lt;code&gt;data/original/switchboard.zip&lt;/code&gt;. To decompress this file we use the &lt;code&gt;unzip()&lt;/code&gt; function with the arguments &lt;code&gt;zipfile&lt;/code&gt; pointing to the &lt;code&gt;.zip&lt;/code&gt; file and &lt;code&gt;exdir&lt;/code&gt; specifying the directory where we want the files to be extracted to.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;I encourage you to use the &lt;code&gt;TAB&lt;/code&gt; key to expand the list of options of a function to avoid having to remember the arguments of a function and also to avoid typos. After typing the name of the function and opening &lt;code&gt;(&lt;/code&gt; hit &lt;code&gt;TAB&lt;/code&gt; to view and select the argument(s) you want. Furthermore, the &lt;code&gt;TAB&lt;/code&gt; key can also help you expand paths to files and directories. Note that the expansion will default to the current working directory.&lt;/p&gt;

&lt;/div&gt;

&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Decompress .zip file and extract to our target directory
unzip(zipfile = &amp;quot;data/original/switchboard.zip&amp;quot;, exdir = &amp;quot;data/original/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The directory structure of &lt;code&gt;data/&lt;/code&gt; now should look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data/
├── derived
└── original
    ├── switchboard
    │   ├── README
    │   ├── discourse
    │   ├── disfluency
    │   ├── tagged
    │   ├── timed-transcript
    │   └── transcript
    └── switchboard.zip

3 directories, 7 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point we have acquired the data programmatically and with this code as part of our workflow anyone could run this code and reproduce the same results. The code as it is, however, is not ideally efficient. Firstly the &lt;code&gt;switchboard.zip&lt;/code&gt; file is not strictly needed after we decompress it and it occupies disk space if we keep it. And second, each time we run this code the file will be downloaded from the remote serve leading to unnecessary data transfer and server traffic. Let’s tackle each of these issues in turn.&lt;/p&gt;
&lt;p&gt;To avoid writing the &lt;code&gt;switchboard.zip&lt;/code&gt; file to disk (long-term) we can use the &lt;code&gt;tempfile()&lt;/code&gt; function to open a temporary holding space for the file. This space can then be used to store the file, unzip it, and then the temporary file will be destroyed. We assign the temporary space to an R object we will name &lt;code&gt;temp&lt;/code&gt; with the &lt;code&gt;tempfile()&lt;/code&gt; function. This object can now be used as the value of the argument &lt;code&gt;destfile&lt;/code&gt; in the &lt;code&gt;download.file()&lt;/code&gt; function. Let’s also assign the web address to another object &lt;code&gt;url&lt;/code&gt; which we will use as the value of the &lt;code&gt;url&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create a temporary file space for our .zip file
temp &amp;lt;- tempfile()
# Assign our web address to `url`
url &amp;lt;- &amp;quot;https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/packages/corpora/switchboard.zip&amp;quot;
# Download .zip file and write to disk
download.file(url, temp)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;In the previous code I’ve used the values stored in the objects &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;temp&lt;/code&gt; in the &lt;code&gt;download.file()&lt;/code&gt; function without specifying the argument names –only providing the names of the objects. R will assume that values of a function map to the ordering of the arguments. If your values do not map to ordering of the arguments you are required to specify the argument name and the value. To view the ordering of objects hit &lt;code&gt;TAB&lt;/code&gt; after entering the function name or consult the function documentation by prefixing the function name with &lt;code&gt;?&lt;/code&gt; and hitting &lt;code&gt;ENTER&lt;/code&gt;.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;At this point our downloaded file is stored temporarily on disk and can be accessed and decompressed to our target directory using &lt;code&gt;temp&lt;/code&gt; as the value for the argument &lt;code&gt;zipfile&lt;/code&gt; from the &lt;code&gt;unzip()&lt;/code&gt; function. I’ve assigned our target directory path to &lt;code&gt;target_dir&lt;/code&gt; and used it as the value for the argument &lt;code&gt;exdir&lt;/code&gt; to prepare us for the next tweak on our approach.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Assign our target directory to `target_dir`
target_dir &amp;lt;- &amp;quot;data/original/&amp;quot;
# Decompress .zip file and extract to our target directory
unzip(zipfile = temp, exdir = target_dir)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our directory structure now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data/
├── derived
└── original
    └── switchboard
        ├── README
        ├── discourse
        ├── disfluency
        ├── tagged
        ├── timed-transcript
        └── transcript

3 directories, 6 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second issue I raised concerns the fact that running this code as part of our project will repeat the download each time. Since we would like to be good citizens and avoid unnecessary traffic on the web it would be nice if our code checked to see if we already have the data on disk and if it exists, then skip the download, if not then download it. To achieve this we need to introduce two new functions &lt;code&gt;if()&lt;/code&gt; and &lt;code&gt;dir.exists()&lt;/code&gt;. &lt;code&gt;dir.exists()&lt;/code&gt; takes a path to a directory as an argument and returns the logical value, &lt;code&gt;TRUE&lt;/code&gt;, if that directory exists, and &lt;code&gt;FALSE&lt;/code&gt; if it does not. &lt;code&gt;if()&lt;/code&gt; evaluates logical statements and processes subsequent code based on the logical value it is passed as an argument. Let’s look at a toy example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;num &amp;lt;- 1
if(num == 1) { 
  cat(num, &amp;quot;is 1&amp;quot;) 
  } else {
  cat(num, &amp;quot;is not 1&amp;quot;)
  }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1 is 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I assigned &lt;code&gt;num&lt;/code&gt; to the value &lt;code&gt;1&lt;/code&gt; and created a logical evaluation &lt;code&gt;num ==&lt;/code&gt; whose result is passed as the argument to &lt;code&gt;if()&lt;/code&gt;. If the statement returns &lt;code&gt;TRUE&lt;/code&gt; then the code withing the first set of curly braces &lt;code&gt;{...}&lt;/code&gt; is run. If &lt;code&gt;num == 1&lt;/code&gt; is false, like in the code below, the code withing the braces following the &lt;code&gt;else&lt;/code&gt; will be run.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;num &amp;lt;- 2
if(num == 1) { 
  cat(num, &amp;quot;is 1&amp;quot;) 
  } else {
  cat(num, &amp;quot;is not 1&amp;quot;)
  }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2 is not 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;if()&lt;/code&gt; is one of various functions that are called &lt;strong&gt;control statements&lt;/strong&gt;. Theses functions provide a lot of power to make dynamic choices as code is run.&lt;/p&gt;
&lt;p&gt;Before we get back to our key objective to avoid downloading resources that we already have on disk, let me introduce another strategy to making code more powerful and ultimately more efficient and as well as more legible –the &lt;strong&gt;custom function&lt;/strong&gt;. Custom functions are functions that the user writes to create a set of procedures that can be run in similar contexts. I’ve created a custom function named &lt;code&gt;eval_num()&lt;/code&gt; below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num &amp;lt;- function(num) {
  if(num == 1) { 
  cat(num, &amp;quot;is 1&amp;quot;) 
  } else {
  cat(num, &amp;quot;is not 1&amp;quot;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s take a closer look at what’s going on here. The function &lt;code&gt;function()&lt;/code&gt; creates a function in which the user decides what arguments are necessary for the code to perform its task. In this case the only necessary argument is the object to store a numeric value to be evaluated. I’ve called it &lt;code&gt;num&lt;/code&gt; because it reflects the name of the object in our toy example, but there is nothing special about this name. It’s only important that the object names be consistently used. I’ve included our previous code (except for the hard-coded assignment of &lt;code&gt;num&lt;/code&gt;) inside the curly braces and assigned the entire code chunk to &lt;code&gt;eval_num&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can now use the function &lt;code&gt;eval_num()&lt;/code&gt; to perform the task of evaluating whether a value of &lt;code&gt;num&lt;/code&gt; is or is not equal to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num(num = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1 is 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num(num = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2 is not 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval_num(num = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3 is not 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’ve put these coding strategies together with our previous code in a function I named &lt;code&gt;get_zip_data()&lt;/code&gt;. There is a lot going on here. Take a look first and see if you can follow the logic involved given what you now know.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_zip_data &amp;lt;- function(url, target_dir) {
  # Function: to download and decompress a .zip file to a target directory
  
  # Check to see if the data already exists
  if(!dir.exists(target_dir)) { # if data does not exist, download/ decompress
    cat(&amp;quot;Creating target data directory \n&amp;quot;) # print status message
    dir.create(path = target_dir, recursive = TRUE, showWarnings = FALSE) # create target data directory
    cat(&amp;quot;Downloading data... \n&amp;quot;) # print status message
    temp &amp;lt;- tempfile() # create a temporary space for the file to be written to
    download.file(url = url, destfile = temp) # download the data to the temp file
    unzip(zipfile = temp, exdir = target_dir, junkpaths = TRUE) # decompress the temp file in the target directory
    cat(&amp;quot;Data downloaded! \n&amp;quot;) # print status message
  } else { # if data exists, don&amp;#39;t download it again
    cat(&amp;quot;Data already exists \n&amp;quot;) # print status message
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK. You should have recognized the general steps in this function: the argument &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;target_dir&lt;/code&gt; specify where to get the data and where to write the decompressed files, the &lt;code&gt;if()&lt;/code&gt; statement evaluates whether the data already exists, if not (&lt;code&gt;!dir.exists(target_dir)&lt;/code&gt;) then the data is downloaded and decompressed, if it does exist (&lt;code&gt;else&lt;/code&gt;) then it is not downloaded.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The prefixed &lt;code&gt;!&lt;/code&gt; in the logical expression &lt;code&gt;dir.exists(target_dir)&lt;/code&gt; returns the opposite logical value. This is needed in this case so when the target directory exists, the expression will return &lt;code&gt;FALSE&lt;/code&gt;, not &lt;code&gt;TRUE&lt;/code&gt;, and therefore not proceed in downloading the resource.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;There are a couple key tweaks I’ve added that provide some additional functionality. For one I’ve included the function &lt;code&gt;dir.create()&lt;/code&gt; to create the target directory where the data will be written. I’ve also added an additional argument to the &lt;code&gt;unzip()&lt;/code&gt; function, &lt;code&gt;junkpaths = TRUE&lt;/code&gt;. Together these additions allow the user to create an arbitrary directory path where the files, and only the files, will be extracted to on our disk. This will discard the containing directory of the &lt;code&gt;.zip&lt;/code&gt; file which can be helpful when we want to add multiple &lt;code&gt;.zip&lt;/code&gt; files to the same target directory.&lt;/p&gt;
&lt;p&gt;A practical scenario where this applies is when we want to download data from a corpus that is contained in multiple &lt;code&gt;.zip&lt;/code&gt; files but still maintain these files in a single primary data directory. Take for example the &lt;a href=&#34;http://www.linguistics.ucsb.edu/research/santa-barbara-corpus&#34;&gt;Santa Barbara Corpus&lt;/a&gt;. This corpus resource includes a series of interviews in which there is one &lt;code&gt;.zip&lt;/code&gt; file, &lt;code&gt;SBCorpus.zip&lt;/code&gt; which contains the &lt;a href=&#34;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/SBCorpus.zip&#34;&gt;transcribed interviews&lt;/a&gt; and another &lt;code&gt;.zip&lt;/code&gt; file, &lt;code&gt;metadata.zip&lt;/code&gt; which organizes the &lt;a href=&#34;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/metadata.zip&#34;&gt;meta-data&lt;/a&gt; associated with each speaker. Applying our initial strategy to download and decompress the data will lead to the following directory structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    ├── SBCorpus
    │   ├── TRN
    │   └── __MACOSX
    │       └── TRN
    └── metadata
        └── __MACOSX

8 directories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By applying our new custom function &lt;code&gt;get_zip_data()&lt;/code&gt; to the transcriptions and then the meta-data we can better organize the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download corpus transcriptions
get_zip_data(url = &amp;quot;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/SBCorpus.zip&amp;quot;, target_dir = &amp;quot;data/original/sbc/transcriptions/&amp;quot;)

# Download corpus meta-data
get_zip_data(url = &amp;quot;http://www.linguistics.ucsb.edu/sites/secure.lsit.ucsb.edu.ling.d7/files/sitefiles/research/SBC/metadata.zip&amp;quot;, target_dir = &amp;quot;data/original/sbc/meta-data/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now our &lt;code&gt;data/&lt;/code&gt; directory is better organized; both the transcriptions and the meta-data are housed under &lt;code&gt;data/original/sbc/&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    └── sbc
        ├── meta-data
        └── transcriptions

5 directories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we add data from other sources we can keep them logical separate and allow our data collection to scale without creating unnecessary complexity. Let’s add the Switchboard Corpus sample using our &lt;code&gt;get_zip_data()&lt;/code&gt; function to see this in action.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download corpus
get_zip_data(url = &amp;quot;https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/packages/corpora/switchboard.zip&amp;quot;, target_dir = &amp;quot;data/original/scs/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our corpora our housed in their own directories and the files are clearly associated.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    ├── sbc
    │   ├── meta-data
    │   └── transcriptions
    └── scs

6 directories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point we have what we need to continue to the next step in our data analysis project. But before we go, we should do some housekeeping to document and organize this process to make our work reproducible. We will take advantage of the &lt;code&gt;project-template&lt;/code&gt; directory structure, seen below.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── README.md
├── _pipeline.R
├── code
│   ├── acquire_data.R
│   ├── analyze_data.R
│   ├── curate_data.R
│   ├── generate_reports.R
│   └── transform_data.R
├── data
│   ├── derived
│   └── original
├── figures
├── functions
├── log
├── recipes-acquire-data.Rproj
└── report
    ├── article.Rmd
    ├── bibliography.bib
    ├── slides.Rmd
    └── web.Rmd

8 directories, 13 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First it is good practice to separate custom functions from our processing scripts. We can create a file in our &lt;code&gt;functions/&lt;/code&gt; directory named &lt;code&gt;acquire_functions.R&lt;/code&gt; and add our custom function &lt;code&gt;get_zip_data()&lt;/code&gt; there. We then use the &lt;code&gt;source()&lt;/code&gt; function to read that function into our current script to make it available to use as needed. It is good practice to source your functions in the SETUP section of your script.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Load custom functions for this project
source(file = &amp;quot;functions/acquire_functions.R&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Second it is advisable to log the structure of the data in plain text files. You can create a directory tree (as those seen in this post) with the bash command &lt;code&gt;tree&lt;/code&gt; on the command line. R provides a function &lt;code&gt;system()&lt;/code&gt; which will interface the command line. Adding the following code to the LOG section of your &lt;code&gt;acquire_data.R&lt;/code&gt; R script will generate the directory structure for each of the corpora that we have downloaded in this post in the files &lt;code&gt;data_original_sbc.log&lt;/code&gt; and &lt;code&gt;data_original_scs.log&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Log the directory structure of the Santa Barbara Corpus
system(command = &amp;quot;tree data/original/sbc &amp;gt;&amp;gt; log/data_original_sbc.log&amp;quot;)
# Log the directory structure of the Switchboard Corpus sample
system(command = &amp;quot;tree data/original/scs &amp;gt;&amp;gt; log/data_original_scs.log&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our project directory structure now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── README.md
├── _pipeline.R
├── code
│   ├── acquire_data.R
│   ├── analyze_data.R
│   ├── curate_data.R
│   ├── generate_reports.R
│   └── transform_data.R
├── data
│   ├── derived
│   └── original
├── figures
├── functions
│   └── acquire_functions.R
├── log
│   ├── data_original_sbc.log
│   └── data_original_scs.log
├── recipes-acquire-data.Rproj
└── report
    ├── article.Rmd
    ├── bibliography.bib
    ├── slides.Rmd
    └── web.Rmd

8 directories, 15 files&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;round-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Round up&lt;/h2&gt;
&lt;p&gt;In this post we’ve covered how to access, download, and organize data contained in .zip files; the most common format for language data found on repositories and individual sites. This included an introduction to a few key R programming concepts and strategies including using functions, writing custom functions, and controlling program flow with control statements. Our approach was to gather data while also keeping in mind the reproducibility of the code. To this end I introduced programming strategies for avoiding unnecessary web traffic (downloads), scalable directory creation, and data documentation.&lt;/p&gt;
&lt;p&gt;In the next post in this three part mini-series I will cover acquiring data from web services such as Project Gutenberg, Twitter, and Facebook through R packages. Using package interfaces will require additional knowledge of R objects. I will discuss vector types and data frames and show how to manipulate these objects in practical situations like filtering data and writing data to disk in plain-text files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Remember base R packages are installed by default with R and are loaded and accessible by default in each R session.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
