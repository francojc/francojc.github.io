<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on francojc ⟲</title>
    <link>https://francojc.github.io/tags/database/</link>
    <description>Recent content in Database on francojc ⟲</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jerid Francom</copyright>
    <lastBuildDate>Mon, 23 Oct 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/database/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Acquiring data for language research (2/3): package interfaces</title>
      <link>https://francojc.github.io/2017/10/23/acquiring-data-for-language-research-package-interfaces/</link>
      <pubDate>Mon, 23 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://francojc.github.io/2017/10/23/acquiring-data-for-language-research-package-interfaces/</guid>
      <description>&lt;link href=&#34;https://francojc.github.io/rmarkdown-libs/pagedtable/css/pagedtable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://francojc.github.io/rmarkdown-libs/pagedtable/js/pagedtable.js&#34;&gt;&lt;/script&gt;


&lt;!-- TODO:
- Proofread
- Sections (add?)
-
--&gt;
&lt;div id=&#34;package-interfaces&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Package interfaces&lt;/h2&gt;
&lt;p&gt;A convenient alternative method for acquiring data in R is through package interfaces to web services. These interfaces are built using R code to make connections with resources on the web through &lt;strong&gt;Automatic Programming Interfaces&lt;/strong&gt; (APIs). Websites such as Project Gutenberg, Twitter, Facebook, and many others provide APIs to allow access to their data under certain conditions, some more limiting for data collection than others. Programmers (like you!) in the R community take up the task of wrapping calls to an API with R code to make accessing that data from R possible. For example, &lt;a href=&#34;https://CRAN.R-project.org/package=gutenbergr&#34;&gt;gutenbergr&lt;/a&gt; provides access to Project Gutenberg, &lt;a href=&#34;https://CRAN.R-project.org/package=rtweet&#34;&gt;rtweet&lt;/a&gt; to Twitter, and &lt;a href=&#34;https://CRAN.R-project.org/package=Rfacebook&#34;&gt;Rfacebook&lt;/a&gt; to Facebook.&lt;/p&gt;
&lt;p&gt;Using R package interfaces, however, often requires some more knowledge about R objects and functions. Let’s take a look at how to access data from Project Gutenberg through the &lt;code&gt;gutenbergr&lt;/code&gt; package. Along the way we will touch upon various functions and concepts that are key to working with the R data types vectors and data frames including filtering and writing tabular data to disk in plain-text format.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The following code is available on GitHub &lt;code&gt;recipes-acquiring_data&lt;/code&gt; and is built on the &lt;code&gt;recipes-project_template&lt;/code&gt; I have discussed in detail &lt;a href=&#34;https://francojc.github.io/2017/08/31/project-management-for-scalable-data-analysis/&#34;&gt;here&lt;/a&gt; and made accessible &lt;a href=&#34;https://github.com/francojc/recipes-project_template.git&#34;&gt;here&lt;/a&gt;. I encourage you to follow along by downloading the &lt;code&gt;recipes-project_template&lt;/code&gt; with &lt;code&gt;git&lt;/code&gt; from the Terminal or create a new RStudio R Project and select the “Version Control” option.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;To get started let’s install and load the package. The most simple method for downloading an R package in RStudio is to select the ‘Packages’ tab in the Files pane and click the ‘Install’ icon. To ensure that our code is reproducible, however, it is better to approach the installation of packages programmatically. If the package is not part of the R base library, we will not assume that the user will have the package on their system. The code to install and load the &lt;code&gt;gutenbergr&lt;/code&gt; package is:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;gutenbergr&amp;quot;) # install `gutenbergr` package
library(gutenbergr) # load the `gutenbergr` package&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This approach works just fine, but luck has it that there is an R package for installing and loading packages! The &lt;a href=&#34;https://CRAN.R-project.org/package=pacman&#34;&gt;pacman&lt;/a&gt; package includes a set of functions for managing packages. A very useful one is &lt;code&gt;p_load()&lt;/code&gt; which will look for a package on a system, load it if it is found, and install and then load it if it is not found. This helps potentially avoid using unnecessary bandwidth to install packages that may already exist on a user’s system. But, to use &lt;code&gt;pacman&lt;/code&gt; we need to include the code to install and load it with the functions &lt;code&gt;install.packages()&lt;/code&gt; and &lt;code&gt;library()&lt;/code&gt;. I’ve included some code that will mimic the behavior of &lt;code&gt;p_load()&lt;/code&gt; for installing &lt;code&gt;pacman&lt;/code&gt; itself, but as you can see it is not elegant, luckily it’s only used once as we add it to the SETUP section of our master file, &lt;code&gt;_pipeline.R&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Load `pacman`. If not installed, install then load.
if (!require(&amp;quot;pacman&amp;quot;, character.only = TRUE)) {
  install.packages(&amp;quot;pacman&amp;quot;)
  library(&amp;quot;pacman&amp;quot;, character.only = TRUE)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have &lt;code&gt;pacman&lt;/code&gt; installed and loaded into our R session, let’s use the &lt;code&gt;p_load()&lt;/code&gt; function to make sure to install/ load the two packages we will need for the upcoming tasks. If you are following along with the &lt;code&gt;recipes-project_template&lt;/code&gt;, add this code within the SETUP section of the &lt;code&gt;acquire_data.R&lt;/code&gt; file.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Script-specific options or packages
pacman::p_load(tidyverse, gutenbergr)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Note that the arguments &lt;code&gt;tidyverse&lt;/code&gt; and &lt;code&gt;gutenbergr&lt;/code&gt; are comma-separated but not quoted.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;Project Gutenberg provides access to thousands of texts in the public domain. The &lt;code&gt;gutenbergr&lt;/code&gt; package contains a set of tables, or &lt;strong&gt;data frames&lt;/strong&gt; in R speak, that index the meta-data for these texts broken down by text (&lt;code&gt;gutenberg_metadata&lt;/code&gt;), author (&lt;code&gt;gutenberg_authors&lt;/code&gt;), and subject (&lt;code&gt;gutenberg_subjects&lt;/code&gt;). I’ll use the &lt;code&gt;glimpse()&lt;/code&gt; function loaded in the &lt;a href=&#34;https://CRAN.R-project.org/package=tidyverse&#34;&gt;tidyverse&lt;/a&gt; package&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; to summarize the structure of these data frames.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(gutenberg_metadata) # summarize text meta-data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 51,997
## Variables: 8
## $ gutenberg_id        &amp;lt;int&amp;gt; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ...
## $ title               &amp;lt;chr&amp;gt; NA, &amp;quot;The Declaration of Independence of th...
## $ author              &amp;lt;chr&amp;gt; NA, &amp;quot;Jefferson, Thomas&amp;quot;, &amp;quot;United States&amp;quot;, ...
## $ gutenberg_author_id &amp;lt;int&amp;gt; NA, 1638, 1, 1666, 3, 1, 4, NA, 3, 3, NA, ...
## $ language            &amp;lt;chr&amp;gt; &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, ...
## $ gutenberg_bookshelf &amp;lt;chr&amp;gt; NA, &amp;quot;United States Law/American Revolution...
## $ rights              &amp;lt;chr&amp;gt; &amp;quot;Public domain in the USA.&amp;quot;, &amp;quot;Public domai...
## $ has_text            &amp;lt;lgl&amp;gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(gutenberg_authors) # summarize authors meta-data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 16,236
## Variables: 7
## $ gutenberg_author_id &amp;lt;int&amp;gt; 1, 3, 4, 5, 7, 8, 9, 10, 12, 14, 16, 17, 1...
## $ author              &amp;lt;chr&amp;gt; &amp;quot;United States&amp;quot;, &amp;quot;Lincoln, Abraham&amp;quot;, &amp;quot;Henr...
## $ alias               &amp;lt;chr&amp;gt; NA, NA, NA, NA, &amp;quot;Dodgson, Charles Lutwidge...
## $ birthdate           &amp;lt;int&amp;gt; NA, 1809, 1736, NA, 1832, NA, 1819, 1860, ...
## $ deathdate           &amp;lt;int&amp;gt; NA, 1865, 1799, NA, 1898, NA, 1891, 1937, ...
## $ wikipedia           &amp;lt;chr&amp;gt; NA, &amp;quot;http://en.wikipedia.org/wiki/Abraham_...
## $ aliases             &amp;lt;chr&amp;gt; NA, &amp;quot;United States President (1861-1865)/L...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(gutenberg_subjects) # summarize subjects meta-data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 140,173
## Variables: 3
## $ gutenberg_id &amp;lt;int&amp;gt; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5...
## $ subject_type &amp;lt;chr&amp;gt; &amp;quot;lcc&amp;quot;, &amp;quot;lcsh&amp;quot;, &amp;quot;lcsh&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcsh&amp;quot;, &amp;quot;lcs...
## $ subject      &amp;lt;chr&amp;gt; &amp;quot;E201&amp;quot;, &amp;quot;United States. Declaration of Independen...&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The &lt;code&gt;gutenberg_metadata&lt;/code&gt;, &lt;code&gt;gutenberg_authors&lt;/code&gt;, and &lt;code&gt;gutenberg_subjects&lt;/code&gt; are periodically updated. To check to see when each data frame was last updated run:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attr(gutenberg_metadata, &amp;quot;date_updated&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-05-05&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;To download the text itself we use the &lt;code&gt;gutenberg_download()&lt;/code&gt; function which takes one required argument, &lt;code&gt;gutenberg_id&lt;/code&gt;. The &lt;code&gt;gutenberg_download()&lt;/code&gt; function is what is known as ‘vectorized’, that is, it can take a single value or multiple values for the argument &lt;code&gt;gutenberg_id&lt;/code&gt;. Vectorization refers to the process of applying a function to each of the elements stored in a &lt;strong&gt;vector&lt;/strong&gt; –a primary object type in R. A vector is a grouping of values of one of various types including character (&lt;code&gt;chr&lt;/code&gt;), integer (&lt;code&gt;int&lt;/code&gt;), and logical (&lt;code&gt;lgl&lt;/code&gt;) and a data frame is a grouping of vectors. The &lt;code&gt;gutenberg_download()&lt;/code&gt; function takes an integer vector which can be manually added or selected from the &lt;code&gt;gutenberg_metadata&lt;/code&gt; or &lt;code&gt;gutenberg_subjects&lt;/code&gt; data frames using the &lt;code&gt;$&lt;/code&gt; operator (e.g. &lt;code&gt;gutenberg_metadata$gutenberg_id&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Let’s first add them manually here as a toy example by generating a vector of integers from 1 to 5 assigned to the variable name &lt;code&gt;ids&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ids &amp;lt;- 1:5 # integer vector of values 1 to 5
ids&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To download the works from Project Gutenberg corresponding to the &lt;code&gt;gutenberg_id&lt;/code&gt;s 1 to 5, we pass the &lt;code&gt;ids&lt;/code&gt; object to the &lt;code&gt;gutenberg_download()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;works_sample &amp;lt;- gutenberg_download(gutenberg_id = ids) # download works with `gutenberg_id` 1-5
glimpse(works_sample) # summarize `works` dataset&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 2,939
## Variables: 2
## $ gutenberg_id &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1...
## $ text         &amp;lt;chr&amp;gt; &amp;quot;December, 1971  [Etext #1]&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;The Projec...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two attributes are returned: &lt;code&gt;gutenberg_id&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt;. The &lt;code&gt;text&lt;/code&gt; column contains values for each line of text (delimited by a carriage return) for each of the 5 works we downloaded. There are many more attributes available from the Project Gutenberg API that can be accessed by passing a character vector of the attribute names to the argument &lt;code&gt;meta_fields&lt;/code&gt;. The column names of the &lt;code&gt;gutenberg_metadata&lt;/code&gt; data frame contains the available attributes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(gutenberg_metadata) # print the column names of the `gutenberg_metadata` data frame&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;gutenberg_id&amp;quot;        &amp;quot;title&amp;quot;               &amp;quot;author&amp;quot;             
## [4] &amp;quot;gutenberg_author_id&amp;quot; &amp;quot;language&amp;quot;            &amp;quot;gutenberg_bookshelf&amp;quot;
## [7] &amp;quot;rights&amp;quot;              &amp;quot;has_text&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s augment our previous download with the title and author of each of the works. To create a character vector we use the &lt;code&gt;c()&lt;/code&gt; function, then, quote and delimit the individual elements of the vector with a comma.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# download works with `gutenberg_id` 1-5 including `title` and `author` as attributes
works_sample &amp;lt;- gutenberg_download(gutenberg_id = ids, 
                            meta_fields = c(&amp;quot;title&amp;quot;,
                                            &amp;quot;author&amp;quot;))
glimpse(works_sample) # summarize dataset&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 2,939
## Variables: 4
## $ gutenberg_id &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1...
## $ text         &amp;lt;chr&amp;gt; &amp;quot;December, 1971  [Etext #1]&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;The Projec...
## $ title        &amp;lt;chr&amp;gt; &amp;quot;The Declaration of Independence of the United St...
## $ author       &amp;lt;chr&amp;gt; &amp;quot;Jefferson, Thomas&amp;quot;, &amp;quot;Jefferson, Thomas&amp;quot;, &amp;quot;Jeffer...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, in a more practical scenario we would like to select the values of &lt;code&gt;gutenberg_id&lt;/code&gt; by some principled query such as works from a specific author, language, or subject. To do this we first query either the &lt;code&gt;gutenberg_metadata&lt;/code&gt; data frame or the &lt;code&gt;gutenberg_subjects&lt;/code&gt; data frame. Let’s say we want to download a random sample of 10 works from English Literature (Library of Congress Classification, “PR”). Using the &lt;code&gt;filter()&lt;/code&gt; function (part of the &lt;code&gt;tidyverse&lt;/code&gt; package set) we first extract all the Gutenberg ids from &lt;code&gt;gutenberg_subjects&lt;/code&gt; where &lt;code&gt;subject_type == &amp;quot;lcc&amp;quot;&lt;/code&gt; and &lt;code&gt;subject == &amp;quot;PR&amp;quot;&lt;/code&gt; assigning the result to &lt;code&gt;ids&lt;/code&gt;.&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ids &amp;lt;- 
  filter(gutenberg_subjects, subject_type == &amp;quot;lcc&amp;quot;, subject == &amp;quot;PR&amp;quot;)
glimpse(ids)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 7,100
## Variables: 3
## $ gutenberg_id &amp;lt;int&amp;gt; 11, 12, 13, 16, 20, 26, 27, 35, 36, 42, 43, 46, 5...
## $ subject_type &amp;lt;chr&amp;gt; &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, &amp;quot;lcc&amp;quot;, ...
## $ subject      &amp;lt;chr&amp;gt; &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;PR&amp;quot;, &amp;quot;...&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;p&gt;The operators &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; are not equivalents. &lt;code&gt;==&lt;/code&gt; is used for logical evaluation and &lt;code&gt;=&lt;/code&gt; is an alternate notation for variable assignment (&lt;code&gt;&amp;lt;-&lt;/code&gt;).&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;gutenberg_subjects&lt;/code&gt; data frame does not contain information as to whether a &lt;code&gt;gutenberg_id&lt;/code&gt; is associated with a plain-text version. To limit our query to only those English Literature works with text, we filter the &lt;code&gt;gutenberg_metadata&lt;/code&gt; data frame by the ids we have selected in &lt;code&gt;ids&lt;/code&gt; and the attribute &lt;code&gt;has_text&lt;/code&gt; in the &lt;code&gt;gutenberg_metadata&lt;/code&gt; data frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ids_has_text &amp;lt;- 
  filter(gutenberg_metadata, gutenberg_id %in% ids$gutenberg_id, has_text == TRUE)
glimpse(ids_has_text)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 6,724
## Variables: 8
## $ gutenberg_id        &amp;lt;int&amp;gt; 11, 12, 13, 16, 20, 26, 27, 35, 36, 42, 43...
## $ title               &amp;lt;chr&amp;gt; &amp;quot;Alice&amp;#39;s Adventures in Wonderland&amp;quot;, &amp;quot;Throu...
## $ author              &amp;lt;chr&amp;gt; &amp;quot;Carroll, Lewis&amp;quot;, &amp;quot;Carroll, Lewis&amp;quot;, &amp;quot;Carro...
## $ gutenberg_author_id &amp;lt;int&amp;gt; 7, 7, 7, 10, 17, 17, 23, 30, 30, 35, 35, 3...
## $ language            &amp;lt;chr&amp;gt; &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, ...
## $ gutenberg_bookshelf &amp;lt;chr&amp;gt; &amp;quot;Children&amp;#39;s Literature&amp;quot;, &amp;quot;Children&amp;#39;s Liter...
## $ rights              &amp;lt;chr&amp;gt; &amp;quot;Public domain in the USA.&amp;quot;, &amp;quot;Public domai...
## $ has_text            &amp;lt;lgl&amp;gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, ...&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;A couple R programming notes on the code phrase &lt;code&gt;gutenberg_id %in% ids$gutenberg_id&lt;/code&gt;. First, the &lt;code&gt;$&lt;/code&gt; symbol in &lt;code&gt;ids$gutenberg_id&lt;/code&gt; is the programmatic way to target a particular column in an R data frame. In this example we select the &lt;code&gt;ids&lt;/code&gt; data frame and the column &lt;code&gt;gutenberg_id&lt;/code&gt;, which is a integer vector. The &lt;code&gt;gutenberg_id&lt;/code&gt; variable that precedes the &lt;code&gt;%in%&lt;/code&gt; operator does not need an explicit reference to a data frame because the primary argument of the &lt;code&gt;filter()&lt;/code&gt; function is this data frame (&lt;code&gt;gutenberg_metadata&lt;/code&gt;). Second, the &lt;code&gt;%in%&lt;/code&gt; operator logically evaluates whether the vector elements in &lt;code&gt;gutenberg_metadata$gutenberg_ids&lt;/code&gt; are also found in the vector &lt;code&gt;ids$gutenberg_id&lt;/code&gt; returning &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; accordingly. This effectively filters those ids which are not in both vectors.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;As we can see the number of works with text is fewer than the number of works listed, 7100 versus 6724. Now we can safely do our random selection of 10 works, with the function &lt;code&gt;sample_n()&lt;/code&gt; and be confident that the ids we select will contain text when we take the next step by downloading the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123) # make the sampling reproducible
ids_sample &amp;lt;- sample_n(ids_has_text, 10) # sample 10 works
glimpse(ids_sample) # summarize the dataset&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 10
## Variables: 8
## $ gutenberg_id        &amp;lt;int&amp;gt; 7688, 33533, 12160, 37761, 40406, 1050, 18...
## $ title               &amp;lt;chr&amp;gt; &amp;quot;Lucretia — Volume 04&amp;quot;, &amp;quot;The Convict&amp;#39;s Far...
## $ author              &amp;lt;chr&amp;gt; &amp;quot;Lytton, Edward Bulwer Lytton, Baron&amp;quot;, &amp;quot;Pa...
## $ gutenberg_author_id &amp;lt;int&amp;gt; 761, 35765, 1865, 1256, 25821, 467, 1062, ...
## $ language            &amp;lt;chr&amp;gt; &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, &amp;quot;en&amp;quot;, ...
## $ gutenberg_bookshelf &amp;lt;chr&amp;gt; NA, NA, NA, NA, NA, &amp;quot;One Act Plays&amp;quot;, NA, N...
## $ rights              &amp;lt;chr&amp;gt; &amp;quot;Public domain in the USA.&amp;quot;, &amp;quot;Public domai...
## $ has_text            &amp;lt;lgl&amp;gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As before, we can now pass our ids (&lt;code&gt;ids_sample$gutenberg_id&lt;/code&gt;) as the argument of &lt;code&gt;gutenberg_download()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;works_pr &amp;lt;- gutenberg_download(gutenberg_id = ids_sample$gutenberg_id, meta_fields = c(&amp;quot;author&amp;quot;, &amp;quot;title&amp;quot;))
glimpse(works_pr) # summarize the dataset&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 79,200
## Variables: 4
## $ gutenberg_id &amp;lt;int&amp;gt; 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1...
## $ text         &amp;lt;chr&amp;gt; &amp;quot;THE DARK LADY OF THE SONNETS&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;By Bernard S...
## $ author       &amp;lt;chr&amp;gt; &amp;quot;Shaw, Bernard&amp;quot;, &amp;quot;Shaw, Bernard&amp;quot;, &amp;quot;Shaw, Bernard&amp;quot;...
## $ title        &amp;lt;chr&amp;gt; &amp;quot;The Dark Lady of the Sonnets&amp;quot;, &amp;quot;The Dark Lady of...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point we have data and could move on to processing this data in preparation for analysis. However, we are aiming for a reproducible workflow and this code does not conform to our principle of modularity: each subsequent step in our analysis will depend on running this code first. Furthermore, running this code as it is creates issues with bandwidth, as in our previous examples from direct downloads. To address modularity we will write the data to disk in &lt;strong&gt;plain-text format&lt;/strong&gt;. In this way each subsequent step in our analysis can access the data locally. To address bandwidth concerns, we will devise a method for checking to see if the data is already downloaded and skip the download, if possible, to avoid accessing the Project Gutenberg server unnecessarily.&lt;/p&gt;
&lt;p&gt;To write our data frame to disk we will export it into a standard plain-text format for two-dimensional data: a CSV file (comma-separated value). The CSV structure for this data will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## gutenberg_id,text,author,title
## 1050,THE DARK LADY OF THE SONNETS,&amp;quot;Shaw, Bernard&amp;quot;,The Dark Lady of the Sonnets
## 1050,,&amp;quot;Shaw, Bernard&amp;quot;,The Dark Lady of the Sonnets
## 1050,By Bernard Shaw,&amp;quot;Shaw, Bernard&amp;quot;,The Dark Lady of the Sonnets
## 1050,,&amp;quot;Shaw, Bernard&amp;quot;,The Dark Lady of the Sonnets
## 1050,,&amp;quot;Shaw, Bernard&amp;quot;,The Dark Lady of the Sonnets
## 1050,,&amp;quot;Shaw, Bernard&amp;quot;,The Dark Lady of the Sonnets&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line contains the names of the columns and subsequent lines the observations. Data points that contain commas themselves (e.g. “Shaw, Bernard”) are quoted to avoid misinterpreting these commas a deliminators in our data. To write this data to disk we will use the &lt;code&gt;write_csv()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;write_csv(works_pr, path = &amp;quot;data/original/gutenberg_works_pr.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To avoid downloading data that already resides on disk, let’s implement a similar strategy to the one used in the previous post for &lt;a href=&#34;https://francojc.github.io/2017/10/20/acquiring-data-for-language-research-direct-downloads/&#34;&gt;direct downloads&lt;/a&gt;. I’ve incorporated the code for sampling and downloading data for a particular subject from Project Gutenberg with a control statement to check if the data file already exists into a function I named &lt;code&gt;get_gutenberg_subject()&lt;/code&gt;. Take a look at this function below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_gutenberg_subject &amp;lt;- function(subject, target_file, sample_size = 10) {
  # Function: to download texts from Project Gutenberg with 
  # a specific LCC subject and write the data to disk.
  
  # Check to see if the data already exists
  if(!file.exists(target_file)) { # if data does not exist, download and write
    target_dir &amp;lt;- dirname(x) # generate target directory for the .csv file
    dir.create(path = target_dir, recursive = TRUE, showWarnings = FALSE) # create target data directory
    cat(&amp;quot;Downloading data... \n&amp;quot;) # print status message
    # Select all records with a particular LCC subject
    ids &amp;lt;- 
      filter(gutenberg_subjects, 
             subject_type == &amp;quot;lcc&amp;quot;, subject == subject) # select subject
    # Select only those records with plain text available
    set.seed(123) # make the sampling reproducible
    ids_sample &amp;lt;- 
      filter(gutenberg_metadata, 
             gutenberg_id %in% ids$gutenberg_id, # select ids in both data frames 
             has_text == TRUE) %&amp;gt;% # select those ids that have text
      sample_n(sample_size) # sample N works (default N = 10)
    # Download sample with associated `author` and `title` metadata
    works_sample &amp;lt;- 
      gutenberg_download(gutenberg_id = ids_sample$gutenberg_id, 
                         meta_fields = c(&amp;quot;author&amp;quot;, &amp;quot;title&amp;quot;))
    # Write the dataset to disk in .csv format
    write_csv(works_sample, path = target_file)
    cat(&amp;quot;Data downloaded! \n&amp;quot;) # print status message
  } else { # if data exists, don&amp;#39;t download it again
    cat(&amp;quot;Data already exists \n&amp;quot;) # print status message
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Adding this function to our function script &lt;code&gt;functions/acquire_functions.R&lt;/code&gt;, we can now use this function in our &lt;code&gt;code/acquire_data.R&lt;/code&gt; script to download multiple subjects and store them in on disk in their own file.&lt;/p&gt;
&lt;p&gt;Let’s download American Literature now (LCC code “PQ”).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Download Project Gutenberg text for subject &amp;#39;PQ&amp;#39; (American Literature)
# and then write this dataset to disk in .csv format
get_gutenberg_subject(subject = &amp;quot;PQ&amp;quot;, target_file = &amp;quot;data/original/gutenberg/works_pq.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Applying this function to both the English and American Literature datasets, our data directory structure now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data
├── derived
└── original
    ├── gutenberg
    │   ├── works_pq.csv
    │   └── works_pr.csv
    ├── sbc
    │   ├── meta-data
    │   └── transcriptions
    └── scs
        ├── README
        ├── discourse
        ├── disfluency
        ├── tagged
        ├── timed-transcript
        └── transcript

7 directories, 8 files&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And as before in the previous post, it is a good idea to log the results of our work.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Log the directory structure of the Project Gutenberg data
system(command = &amp;quot;tree data/original/gutenberg &amp;gt;&amp;gt; log/data_original_gutenberg.log&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;!-- then work with a more complex package interface. Introduce the `fulltext` package (or [crminer](https://github.com/ropensci/crminer) . Show how to search a specific publication, download the full text (in XML) format. Then extract the `doi`, `title`, and `abstract`, convert it to a data.frame and store it as a `.csv` file. 

TODO: - work with `fulltext` and `crminer` exploration/ package tutorials
      - determine the R skills needed to complete this activity

Search for Plos ONE publications in Linguistics?
--&gt;
&lt;/div&gt;
&lt;div id=&#34;round-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Round up&lt;/h2&gt;
&lt;p&gt;In this post I provided an overview to acquiring data from web service APIs through R packages. We took at closer look at the &lt;code&gt;gutenbergr&lt;/code&gt; package which provides programmatic access to works available on Project Gutenberg. Working with package interfaces requires more knowledge of R including loading/ installing packages, working with vectors and data frames, and exporting data from an R session. We touched on these programming concepts and also outlined a method to create a reproducible workflow.&lt;/p&gt;
&lt;p&gt;Our last step in this mini series on acquiring data for language research with R, we will explore methods for acquire language data from the browsable web. I will discuss using the &lt;code&gt;rvest&lt;/code&gt; package for downloading and isolating text elements from HTML pages and show how to organize and write the data to disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-R-gutenbergr&#34;&gt;
&lt;p&gt;Robinson, David. 2017. &lt;em&gt;Gutenbergr: Download and Process Public Domain Works from Project Gutenberg&lt;/em&gt;. &lt;a href=&#34;https://CRAN.R-project.org/package=gutenbergr&#34; class=&#34;uri&#34;&gt;https://CRAN.R-project.org/package=gutenbergr&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-R-tidyverse&#34;&gt;
&lt;p&gt;Wickham, Hadley. 2017. &lt;em&gt;Tidyverse: Easily Install and Load ’Tidyverse’ Packages&lt;/em&gt;. &lt;a href=&#34;https://CRAN.R-project.org/package=tidyverse&#34; class=&#34;uri&#34;&gt;https://CRAN.R-project.org/package=tidyverse&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;&lt;code&gt;tidyverse&lt;/code&gt; is not a typical package. It is a set of packages: &lt;code&gt;ggplot2&lt;/code&gt;, &lt;code&gt;dplyr&lt;/code&gt;, &lt;code&gt;tidyr&lt;/code&gt;, &lt;code&gt;readr&lt;/code&gt;, &lt;code&gt;purrr&lt;/code&gt;, and &lt;code&gt;tibble&lt;/code&gt;. These packages are all installed/ loaded with &lt;code&gt;tidyverse&lt;/code&gt; and form the backbone for the type of work you will typically do in most analyses.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;See &lt;a href=&#34;https://www.loc.gov/catdir/cpso/lcco/&#34;&gt;Library of Congress Classification&lt;/a&gt; documentation for a complete list of subject codes.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Create an SSH tunnel for a remote MySQL database</title>
      <link>https://francojc.github.io/2011/08/26/create-an-ssh-tunnel-for-a-remote-mysql-database/</link>
      <pubDate>Fri, 26 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>https://francojc.github.io/2011/08/26/create-an-ssh-tunnel-for-a-remote-mysql-database/</guid>
      <description>&lt;p&gt;his isn&amp;rsquo;t that hard to find out on the Internets, but I want to document a couple tips that I find useful once you create an SSH Tunnel to your remote MySQL database. After you create the tunnel, you will be able to interact with the database as if it were on your local machine, which simplifies running SQL scripts.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create an SSH Tunnel&lt;/p&gt;

&lt;p&gt;First open a command-line interface and enter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh user@host -L 3306:localhost:3306
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Connect to the remote database with with local(ish) syntax&lt;/p&gt;

&lt;p&gt;Then open another command-line window (without closing the other session) and enter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mysql -u db_user -h 127.0.0.1 -p
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The explicit &lt;code&gt;127.0.0.1&lt;/code&gt; for localhost seems to be important (I get a connection error when I just specify &lt;code&gt;localhost&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;And there you go, a local interface to your remote MySQL database. A more complete trick-laden version of this post can be found &lt;a href=&#34;https://boxpanel.bluebox.net/public/the_vault/index.php/Tunneling_MySQL_through_SSH&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
